Probelm 1:
(assume h1 (and true (not true)))
(step t2 (cl (= (not true) false)) :rule not_simplify)
(step t3 (cl (= (and true (not true)) (and true false))) :rule cong :premises (t2))
(step t4 (cl (= (and true false) (and false))) :rule and_simplify)
(step t5 (cl (= (and false) false)) :rule and_simplify)
(step t6 (cl (= (and true (not true)) false)) :rule trans :premises (t3 t4 t5))
(step t7 (cl (not (= (and true (not true)) false)) (not (and true (not true))) false) :rule equiv_pos2)
(step t8 (cl false) :rule th_resolution :premises (h1 t6 t7))
(step t9 (cl (not false)) :rule false)
(step t10 (cl) :rule resolution :premises (t8 t9))
Original proof:
    ------notsimp
    ~T = F
--------------cong  -----------andsimp  -------andsimp
T ^ ~T = T ^ F      T ^ F = ^ F         ^ F = F
-----------------------------------------------trans  -------------------------eqp2  ------asmp
                   T ^ ~T = F                         T ^ ~T != F, ~(T ^ ~T), F      T ^ ~T
                   ------------------------------------------------------------------------res  ----false
                                                      F                                          ~F
                                                      ---------------------------------------------
                                                                          []
------notsimp  -------------andn  ------------andp
~T, F          T ^ F, ~T, ~F      ~(T ^ ~T), T
~(T ^ ~T), T ^ F    ~(T ^ F), ^ F    ~(^ F), F
----------------------------------------------res  ------asmp
                ~(T ^ ~T), F                       T ^ ~T 
                -----------------------------------------res  ----false
                                    F                          ~F
                                    -----------------------------
                                                 []
x = y         ~x, y
---------   ----------
f x = f y   ~(f x), f y
Problem 2:
(assume h1 (not (or true false)))
(step t2 (cl (= (or true false) (or true))) :rule or_simplify)
(step t3 (cl (= (or true) true)) :rule or_simplify)
(step t4 (cl (= (or true false) true)) :rule trans :premises (t2 t3))
(step t5 (cl (= (not (or true false)) (not true))) :rule cong :premises (t4))
(step t6 (cl (= (not true) false)) :rule not_simplify)
(step t7 (cl (= (not (or true false)) false)) :rule trans :premises (t5 t6))
(step t8 (cl (not (= (not (or true false)) false)) (not (not (or true false))) false) :rule equiv_pos2)
(step t9 (cl (not (not (not (or true false)))) (or true false)) :rule not_not)
(step t10 (cl (not (= (not (or true false)) false)) (or true false) false) :rule th_resolution :premises (t9 t8))
(step t11 (cl false) :rule th_resolution :premises (h1 t7 t10))
(step t12 (cl (not false)) :rule false)
(step t13 (cl) :rule resolution :premises (t11 t12))
Procedure:
- If you see an `x = y` by `_simp`, replace it by `~x, y` by subproof.
- If you see `cong`, that uses a `_simp` argument (directly, or indirectly through `trans`), remove the `cong`.
- If you see a `trans` that uses `_simp` arguments (directly, or indirectly through `cong`), replace it with `reso`
- If the `eqp2` is resolved with a `_simp` rule or its `cong/trans` derivative, remove the `eqp2`
Idea: the equality proved by the `_simp` rule - `x = y` is transformed into `x' = y'` via `cong` and `trans`, and then used with `eqp2`
to derive the LTR implication `~x', y'`
Original proof:
-----------orsimp  -------orsimp
T v F = v T        v T = T
--------------------------trans
         T v F = T
       -------------cong  --------notsimp  ---------------------------eqp2  -----------------notnot
       ~(T v F) = ~T       ~T = F          ~(T v F) != F, ~~(T v F), F      ~~~(T v F), T v F
       --------------------------trans     --------------------------------------------------res  --------asmp
              ~(T v F) = F                             ~(T v F) != F, T v F, F                    ~(T v F)
              -----------------------------------------------------------------------------------------res  -----false
                                                        F                                                     ~F
                                                        --------------------------------------------------------res
                                                                                    []
Refactored proof:
-------------orsimp  ---------orsimp  --------notsimp
~(T v F), v T        ~(v T), T         ~~T, F        
--------------------------trans
         T v F = T
       -------------cong  --------notsimp  ---------------------------eqp2  -----------------notnot
       ~(T v F) = ~T       ~T = F          ~(T v F) != F, ~~(T v F), F      ~~~(T v F), T v F
       --------------------------trans     --------------------------------------------------res  --------asmp
              ~(T v F) = F                             ~(T v F) != F, T v F, F                    ~(T v F)
              -----------------------------------------------------------------------------------------res  -----false
                                                        F                                                     ~F
                                                        --------------------------------------------------------res
                                                                                    []                                                                                    
Problem 5:
(assume h1 (not (or p (not p))))
(step t2 (cl (= (or p (not p)) true)) :rule or_simplify)
(step t3 (cl (= (not (or p (not p))) (not true))) :rule cong :premises (t2))
(step t4 (cl (= (not true) false)) :rule not_simplify) -- We only have LTR version of this!
(step t5 (cl (= (not (or p (not p))) false)) :rule trans :premises (t3 t4))
(step t6 (cl (not (= (not (or p (not p))) false)) (not (not (or p (not p)))) false) :rule equiv_pos2)
(step t7 (cl (not (not (not (or p (not p))))) (or p (not p))) :rule not_not)
(step t8 (cl (not (= (not (or p (not p))) false)) (or p (not p)) false) :rule th_resolution :premises (t7 t6))
(step t9 (cl false) :rule th_resolution :premises (h1 t5 t8))
(step t10 (cl (not false)) :rule false)
(step t11 (cl) :rule resolution :premises (t9 t10))
Original proof:
----------orsimp
p v ~p = T
--------------cong  ------notsimp  -----------------------------eqp2  -------------------notnot
~(p v ~p) = ~T      ~T = F         ~(p v ~p) != F, ~~(p v ~p), F      ~~~(p v ~p), p v ~p
--------------------------trans    ------------------------------------------------------res  ---------asmp
      ~(p v ~p) = F                             ~(p v ~p) != F, p v ~p, F                     ~(p v ~p)
      -------------------------------------------------------------------------------------------------res  -----false
                                                  F                                                           ~F
                                                  --------------------------------------------------------------res
                                                                               []
Refactored proof:
------------orsimp  -----notsimp
~(p v ~p), T        ~T, F
-------------------------res  ---------asmp
      ~(p v ~p), F             ~(p v ~p)  
      ----------------------------------res  -----false
                    F                         ~F
                    ----------------------------res
                                 []

x ^ F <-> F
  --asmp
  F
-------weaken  ---false
F v x           ~F
------------------res  --asmp  ---------------andn
         x             F        x ^ F, ~x, ~F
         -------------------------------------res
                        x ^ F

x ^ ~x <-> F
  --asmp                   --asmp
  F                        F
-------weaken  ---false  -------weaken  ---false
F v x           ~F       F v ~x          ~F
------------------res    ------------------res  ----------------andn
         x                        ~x             x ^ ~x, ~x, ~~x
         -------------------------------------------------------res
                                  x ^ ~x

~T <-> F
  ---asmp
   F
--------weaken   ------false
F v ~T             ~F
------------------------res
            ~T

(x <-> ~x) <-> F
  --asmp                   --asmp
  F                        F
-------weaken  ---false  -------weaken  ---false
F v x           ~F       F v ~x          ~F
------------------res    ------------------res  ------------------eqn1
         x                        ~x             x <-> ~x, ~x, ~~x
         ---------------------------------------------------------res
                                  x <-> ~x

(~x <-> x) <-> F
  --asmp                   --asmp
  F                        F
-------weaken  ---false  -------weaken  ---false
F v x           ~F       F v ~x          ~F
------------------res    ------------------res  ------------------eqn1
         x                        ~x             ~x <-> x, ~~x, ~x
         ---------------------------------------------------------res
                                  ~x <-> x

ite c x F <-> ~c v x
------asmp
~c v x    
-----------------iten2
ite c x F, ~c, ~x     
-----------------iten1    
ite c x F, c, ~F
------------------itep2
~(ite c x F), ~c, F
------------------itep1
~(ite c x F), c, F     
----------------orp
~(~c v x), ~c, x

process_simplify:
---------------eqn1    -----subp      -------------eqn2  ------subp
   a <-> b, ~a, ~b        ~a, b          a <-> b, a, b      a, ~b
   --------------------------------res   ------------------------res
              a <-> b, ~a                      a <-> b, a
              -------------------------------------------res
                                 a <-> b
1. eqn1,   a <-> b, ~a, ~b
2. subp,   ~a, b
3. res     a <-> b, ~a     1,2
4. eqn2,   a <-> b, a, b
5. subp,   a, ~b
6. res     a <-> b, a      4,5
7. res     a <-> b         3,6

  Pi_1                                         Pi_1
...                                     ...
--------                                -----------------and_neg
| [H]  |                                [(H ^ ~G), ~H, G]               --(2)
| Pi_2 |                                ...       
|  G   |                                Pi_3'
--------               ----->           ...        
 [~H, G] --(1)                          H ^ ~G                          --(3)
...                                     --------and'
  Pi_3                                      H --(4)         H ^ ~G      --(3)      
...                                        Pi_2             ------and'        
   []                                       G                 ~G        --(5)
                                            --------------------
                                                     []                 --(6)
where        
 - Pi_3' replaces every step in Pi_3 that directly or indirectly uses (1), so that the result 
   naturally produces the original result v (H ^ ~G) 
 - and' is and implemented through andPos and reso

(h1, AssumeAST, (cl  ((x = y))), [], [])
(h2, AssumeAST, (cl  ((a = b))), [], [])
(h3, AssumeAST, (cl  ((not ((and  x (true) a) = (and  y (true) b))))), [], [])
(x2, EqcpAST, (cl  ((not (x = y))) ((not ((true) = (true)))) ((not (a = b))) ((not (and  x (true) a))) ((and  y (true) b))), [], [])
(x4, Equn2AST, (cl  (((and  x (true) a) = (and  y (true) b))) ((and  x (true) a)) ((and  y (true) b))), [], [])
(x6, ResoAST, (cl  ((not (x = y))) ((not ((true) = (true)))) ((not (a = b))) (((and  x (true) a) = (and  y (true) b))) ((and  y (true) b))), [ x2 x4], [])
(x3, EqcpAST, (cl  ((not (x = y))) ((not ((true) = (true)))) ((not (a = b))) ((not (and  y (true) b))) ((and  x (true) a))), [], [])
(x5, Equn1AST, (cl  (((and  x (true) a) = (and  y (true) b))) ((not (and  x (true) a))) ((not (and  y (true) b)))), [], [])
(x7, ResoAST, (cl  ((not (x = y))) ((not ((true) = (true)))) ((not (a = b))) (((and  x (true) a) = (and  y (true) b))) ((not (and  y (true) b)))), [ x3 x5], [])
(x1, ReflAST, (cl  (((true) = (true)))), [], [])
(t4, ResoAST, (cl  (((and  x (true) a) = (and  y (true) b)))), [ x6 x7 h1 h2 x1], [])
(t5, ResoAST, (cl ), [ h3 t4], [])


-------------------------------------------------------ecp  -------------------------------------------------eqn2 -------------------------------------------------------ecp  ---------------------------------------------------eqn1
~(x = y), ~(T = T), ~(a = b), ~(x ^ T ^ a), (y ^ T ^ b)     (x ^ T ^ a = y ^ T ^ b), (x ^ T ^ a), (y ^ T ^ b)     ~(x = y), ~(T = T), ~(a = b), ~(y ^ T ^ b), (x ^ T ^ a)     (x ^ T ^ a = y ^ T ^ b), ~(x ^ T ^ a), ~(y ^ T ^ b)
-------------------------------------------------------------------------------------------------------------res  -------------------------------------------------------------------------------------------------------------res    -----refl ------asmp  ------asmp
                              ~(x = y), ~(T = T), ~(a = b), (x ^ T ^ a = y ^ T ^ b), (y ^ T ^ b)                                         ~(x = y), ~(T = T), ~(a = b), (x ^ T ^ a = y ^ T ^ b), ~(y ^ T ^ b)                          T = T     x = y       a = b
------------------------asmp  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------res
~(x ^ T ^ a = y ^ T ^ b)                                                                                                      (x ^ T ^ a = y ^ T ^ b)
------------------------------------------------------------------------------------------------------------------------------------------------------res
                                                                    []