(assume a0 (not (or (not (= (f x) y)) (not (g (f x))) (g y))))
(step t1 (cl (not (= (not (or (not (= (f x) y)) (not (g (f x))) (g y))) (not (or (not (g (f x))) (g (f x)))))) (not (not (or (not (= (f x) y)) (not (g (f x))) (g y)))) (not (or (not (g (f x))) (g (f x))))) :rule equiv_pos2)
(step t2 (cl (= (= (f x) y) (= y (f x)))) :rule hole :args (ARITH_POLY_NORM (= (= (f x) y) (= y (f x)))))
(step t3 (cl (= (not (= (f x) y)) (not (= y (f x))))) :rule cong :premises (t2))
(step t4 (cl (= (not (g (f x))) (not (g (f x))))) :rule refl)
(step t5 (cl (= (g y) (g y))) :rule refl)
(step t6 (cl (= (or (not (= (f x) y)) (not (g (f x))) (g y)) (or (not (= y (f x))) (not (g (f x))) (g y)))) :rule cong :premises (t3 t4 t5))
(step t7 (cl (= (not (or (not (= (f x) y)) (not (g (f x))) (g y))) (not (or (not (= y (f x))) (not (g (f x))) (g y))))) :rule cong :premises (t6))
(step t8 (cl (not (not (not (= y (f x))))) (= y (f x))) :rule not_not)
(step t9 (cl (not (= (not (or (not (= (f x) y)) (not (g (f x))) (g y))) (not (or (not (= y (f x))) (not (g (f x))) (g y))))) (not (not (or (not (= (f x) y)) (not (g (f x))) (g y)))) (not (or (not (= y (f x))) (not (g (f x))) (g y)))) :rule equiv_pos2)
(step t10 (cl (not (or (not (= y (f x))) (not (g (f x))) (g y)))) :rule resolution :premises (t9 t7 a0))
(step t11 (cl (not (not (= y (f x))))) :rule not_or :premises (t10))
(step t12 (cl (= y (f x))) :rule resolution :premises (t8 t11))
(step t13 (cl (= (f x) (f x))) :rule refl)
(step t14 (cl (= (= y (f x)) (= (f x) (f x)))) :rule cong :premises (t12 t13))
(step t15 (cl (= (not (= y (f x))) (not (= (f x) (f x))))) :rule cong :premises (t14))
(step t16 (cl (= (not (g (f x))) (not (g (f x))))) :rule refl)
(step t17 (cl (= (g y) (g (f x)))) :rule cong :premises (t12))
(step t18 (cl (= (or (not (= y (f x))) (not (g (f x))) (g y)) (or (not (= (f x) (f x))) (not (g (f x))) (g (f x))))) :rule cong :premises (t15 t16 t17))
(step t19 (cl (= (not (or (not (= y (f x))) (not (g (f x))) (g y))) (not (or (not (= (f x) (f x))) (not (g (f x))) (g (f x)))))) :rule cong :premises (t18))
(step t20 (cl (= (= (f x) (f x)) true)) :rule all_simplify :args (eq_simplify1 (f x)))
(step t21 (cl (= (not (= (f x) (f x))) (not true))) :rule cong :premises (t20))
(step t22 (cl (= (not true) false)) :rule not_simplify)
(step t23 (cl (= (not (= (f x) (f x))) false)) :rule trans :premises (t21 t22))
(step t24 (cl (= (g (f x)) (g (f x)))) :rule refl)
(step t25 (cl (= (or (not (= (f x) (f x))) (not (g (f x))) (g (f x))) (or false (not (g (f x))) (g (f x))))) :rule cong :premises (t23 t4 t24))
(step t26 (cl (= (or false (not (g (f x))) (g (f x))) (or (not (g (f x))) (g (f x))))) :rule all_simplify :args (or_simplify2 (cvc5_nary_op) (cvc5_nary_op (not (g (f x))))))
(step t27 (cl (= (or (not (= (f x) (f x))) (not (g (f x))) (g (f x))) (or (not (g (f x))) (g (f x))))) :rule trans :premises (t25 t26))
(step t28 (cl (= (not (or (not (= (f x) (f x))) (not (g (f x))) (g (f x)))) (not (or (not (g (f x))) (g (f x)))))) :rule cong :premises (t27))
(step t29 (cl (= (not (or (not (= y (f x))) (not (g (f x))) (g y))) (not (or (not (g (f x))) (g (f x)))))) :rule trans :premises (t19 t28))
(step t30 (cl (= (not (or (not (= (f x) y)) (not (g (f x))) (g y))) (not (or (not (g (f x))) (g (f x)))))) :rule trans :premises (t7 t29))
(step t31 (cl (not (or (not (g (f x))) (g (f x))))) :rule resolution :premises (t1 t30 a0))
(step t32 (cl (not (g (f x)))) :rule not_or :premises (t31))
(step t33 (cl (not (not (not (g (f x))))) (g (f x))) :rule not_not)
(step t34 (cl (not (not (g (f x))))) :rule not_or :premises (t31))
(step t35 (cl (g (f x))) :rule resolution :premises (t33 t34))
(step t36 (cl) :rule resolution :premises (t32 t35))
