(assume a0 (not (=> (= y (+ x 1)) (= (f x) (f (- y 1))))))
(step t1 (cl (not (= (not (= (f x) (f (+ (- 1) y)))) false)) (not (not (= (f x) (f (+ (- 1) y))))) false) :rule equiv_pos2)
(step t2 (cl (not (= (not (=> (= y (+ x 1)) (= (f x) (f (- y 1))))) (not (=> (= x (+ (- 1) y)) (= (f x) (f (+ (- 1) y))))))) (not (not (=> (= y (+ x 1)) (= (f x) (f (- y 1)))))) (not (=> (= x (+ (- 1) y)) (= (f x) (f (+ (- 1) y)))))) :rule equiv_pos2)
(step t3 (cl (= y y)) :rule refl)
(step t4 (cl (= (+ x 1) (+ 1 x))) :rule hole :args (ARITH_POLY_NORM (= (+ x 1) (+ 1 x))))
(step t5 (cl (= (= y (+ x 1)) (= y (+ 1 x)))) :rule cong :premises (t3 t4))
(step t6 (cl (= (= y (+ 1 x)) (= x (+ (- 1) y)))) :rule hole :args (ARITH_POLY_NORM (= (= y (+ 1 x)) (= x (+ (- 1) y)))))
(step t7 (cl (= (= y (+ x 1)) (= x (+ (- 1) y)))) :rule trans :premises (t5 t6))
(step t8 (cl (= (f x) (f x))) :rule refl)
(step t9 (cl (= (- y 1) (+ y (* (- 1) 1)))) :rule hole :args (ARITH_POLY_NORM (= (- y 1) (+ y (* (- 1) 1)))))
(step t10 (cl (= (* (- 1) 1) (- 1))) :rule prod_simplify)
(step t11 (cl (= (+ y (* (- 1) 1)) (+ y (- 1)))) :rule cong :premises (t3 t10))
(step t12 (cl (= (+ y (- 1)) (+ (- 1) y))) :rule hole :args (ARITH_POLY_NORM (= (+ y (- 1)) (+ (- 1) y))))
(step t13 (cl (= (+ y (* (- 1) 1)) (+ (- 1) y))) :rule trans :premises (t11 t12))
(step t14 (cl (= (- y 1) (+ (- 1) y))) :rule trans :premises (t9 t13))
(step t15 (cl (= (f (- y 1)) (f (+ (- 1) y)))) :rule cong :premises (t14))
(step t16 (cl (= (= (f x) (f (- y 1))) (= (f x) (f (+ (- 1) y))))) :rule cong :premises (t8 t15))
(step t17 (cl (= (=> (= y (+ x 1)) (= (f x) (f (- y 1)))) (=> (= x (+ (- 1) y)) (= (f x) (f (+ (- 1) y)))))) :rule cong :premises (t7 t16))
(step t18 (cl (= (not (=> (= y (+ x 1)) (= (f x) (f (- y 1))))) (not (=> (= x (+ (- 1) y)) (= (f x) (f (+ (- 1) y))))))) :rule cong :premises (t17))
(step t19 (cl (not (=> (= x (+ (- 1) y)) (= (f x) (f (+ (- 1) y)))))) :rule resolution :premises (t2 t18 a0))
(step t20 (cl (= x (+ (- 1) y))) :rule not_implies1 :premises (t19))
(step t21 (cl (= (f x) (f (+ (- 1) y)))) :rule cong :premises (t20))
(step t22 (cl (= (f (+ (- 1) y)) (f (+ (- 1) y)))) :rule refl)
(step t23 (cl (= (= (f x) (f (+ (- 1) y))) (= (f (+ (- 1) y)) (f (+ (- 1) y))))) :rule cong :premises (t21 t22))
(step t24 (cl (= (not (= (f x) (f (+ (- 1) y)))) (not (= (f (+ (- 1) y)) (f (+ (- 1) y)))))) :rule cong :premises (t23))
(step t25 (cl (= (= (f (+ (- 1) y)) (f (+ (- 1) y))) true)) :rule all_simplify :args (eq_simplify1 (f (+ (- 1) y))))
(step t26 (cl (= (not (= (f (+ (- 1) y)) (f (+ (- 1) y)))) (not true))) :rule cong :premises (t25))
(step t27 (cl (= (not true) false)) :rule not_simplify)
(step t28 (cl (= (not (= (f (+ (- 1) y)) (f (+ (- 1) y)))) false)) :rule trans :premises (t26 t27))
(step t29 (cl (= (not (= (f x) (f (+ (- 1) y)))) false)) :rule trans :premises (t24 t28))
(step t30 (cl (not (= (not (=> (= y (+ x 1)) (= (f x) (f (- y 1))))) (not (=> (= x (+ (- 1) y)) (= (f x) (f (+ (- 1) y))))))) (not (not (=> (= y (+ x 1)) (= (f x) (f (- y 1)))))) (not (=> (= x (+ (- 1) y)) (= (f x) (f (+ (- 1) y)))))) :rule equiv_pos2)
(step t31 (cl (not (=> (= x (+ (- 1) y)) (= (f x) (f (+ (- 1) y)))))) :rule resolution :premises (t30 t18 a0))
(step t32 (cl (not (= (f x) (f (+ (- 1) y))))) :rule not_implies2 :premises (t31))
(step t33 (cl false) :rule resolution :premises (t1 t29 t32))
(step t34 (cl (not false)) :rule false)
(step t35 (cl) :rule resolution :premises (t33 t34))
