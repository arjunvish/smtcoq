(assume a0 (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1))))))
(step t1 (cl (not (= (not (= (op_2 op_1) (op_2 (+ (- 1) op_0)))) false)) (not (not (= (op_2 op_1) (op_2 (+ (- 1) op_0))))) false) :rule equiv_pos2)
(step t2 (cl (not (= (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0))))))) (not (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1)))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule equiv_pos2)
(step t3 (cl (= op_0 op_0)) :rule refl)
(step t4 (cl (= (+ op_1 1) (+ 1 op_1))) :rule hole :args (ARITH_POLY_NORM (= (+ op_1 1) (+ 1 op_1))))
(step t5 (cl (= (= op_0 (+ op_1 1)) (= op_0 (+ 1 op_1)))) :rule cong :premises (t3 t4))
(step t6 (cl (= (= op_0 (+ 1 op_1)) (= op_1 (+ (- 1) op_0)))) :rule hole :args (ARITH_POLY_NORM (= (= op_0 (+ 1 op_1)) (= op_1 (+ (- 1) op_0)))))
(step t7 (cl (= (= op_0 (+ op_1 1)) (= op_1 (+ (- 1) op_0)))) :rule trans :premises (t5 t6))
(step t8 (cl (= (op_2 op_1) (op_2 op_1))) :rule refl)
(step t9 (cl (= (- op_0 1) (+ op_0 (* (- 1) 1)))) :rule hole :args (ARITH_POLY_NORM (= (- op_0 1) (+ op_0 (* (- 1) 1)))))
(step t10 (cl (= (* (- 1) 1) (- 1))) :rule prod_simplify)
(step t11 (cl (= (+ op_0 (* (- 1) 1)) (+ op_0 (- 1)))) :rule cong :premises (t3 t10))
(step t12 (cl (= (+ op_0 (- 1)) (+ (- 1) op_0))) :rule hole :args (ARITH_POLY_NORM (= (+ op_0 (- 1)) (+ (- 1) op_0))))
(step t13 (cl (= (+ op_0 (* (- 1) 1)) (+ (- 1) op_0))) :rule trans :premises (t11 t12))
(step t14 (cl (= (- op_0 1) (+ (- 1) op_0))) :rule trans :premises (t9 t13))
(step t15 (cl (= (op_2 (- op_0 1)) (op_2 (+ (- 1) op_0)))) :rule cong :premises (t14))
(step t16 (cl (= (= (op_2 op_1) (op_2 (- op_0 1))) (= (op_2 op_1) (op_2 (+ (- 1) op_0))))) :rule cong :premises (t8 t15))
(step t17 (cl (= (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1)))) (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule cong :premises (t7 t16))
(step t18 (cl (= (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0))))))) :rule cong :premises (t17))
(step t19 (cl (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule resolution :premises (t2 t18 a0))
(step t20 (cl (= op_1 (+ (- 1) op_0))) :rule not_implies1 :premises (t19))
(step t21 (cl (= (op_2 op_1) (op_2 (+ (- 1) op_0)))) :rule cong :premises (t20))
(step t22 (cl (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0)))) :rule refl)
(step t23 (cl (= (= (op_2 op_1) (op_2 (+ (- 1) op_0))) (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0))))) :rule cong :premises (t21 t22))
(step t24 (cl (= (not (= (op_2 op_1) (op_2 (+ (- 1) op_0)))) (not (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0)))))) :rule cong :premises (t23))
(step t25 (cl (= (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0))) true)) :rule all_simplify :args (eq_simplify1 (op_2 (+ (- 1) op_0))))
(step t26 (cl (= (not (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0)))) (not true))) :rule cong :premises (t25))
(step t27 (cl (= (not true) false)) :rule not_simplify)
(step t28 (cl (= (not (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0)))) false)) :rule trans :premises (t26 t27))
(step t29 (cl (= (not (= (op_2 op_1) (op_2 (+ (- 1) op_0)))) false)) :rule trans :premises (t24 t28))
(step t30 (cl (not (= (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0))))))) (not (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1)))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule equiv_pos2)
(step t31 (cl (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule resolution :premises (t30 t18 a0))
(step t32 (cl (not (= (op_2 op_1) (op_2 (+ (- 1) op_0))))) :rule not_implies2 :premises (t31))
(step t33 (cl false) :rule resolution :premises (t1 t29 t32))
(step t34 (cl (not false)) :rule false)
(step t35 (cl) :rule resolution :premises (t33 t34))

