Encoding ac_simp
l <-> r
RTL:
f(l, r)
case and xs, and ys:
  ys' := for each y in ys, 
           resolve `and ys` and `~(and ys), y` by `andp` to get `y`
  for each x in xs,
    if x in {and} then
    -- an and on LHS is flattened on RHS
      `x, ~x1', ..., ~xn'` by `andn` and recurse 

    if x in {or} then
    -- an or on LHS is either an or on RHS, or it reduces to a literal by duplicate removal
      if x reduces to literal, then 
    if x not in {and, or} then 
    -- a literal on LHS is a literal on RHS
        [i1, Asmp, [r], []]
        [i2, Andp, [~r, x] ,[]]
        [i3, Reso, [x], [i1, i2]]

    find x in ys
      if x is in top-level(ys)
        
      else recurse into each 
Encode      
-------------------------------------------------------ac_simp
a ^ (b ^ c) ^ (x v (y v z)) <-> a ^ b ^ c ^ (x v y v z)
Into:
RTL:
-----------------------asmp  -----------------------------andp
a ^ b ^ c ^ (x v y v c)      ~(a ^ b ^ c ^ (x v y v z)), a
----------------------------------------------------------res
                             a --(1)

-----------------------asmp  -----------------------------andp
a ^ b ^ c ^ (x v y v c)      ~(a ^ b ^ c ^ (x v y v z)), b
----------------------------------------------------------res
                             b --(2)

-----------------------asmp  -----------------------------andp
a ^ b ^ c ^ (x v y v c)      ~(a ^ b ^ c ^ (x v y v z)), c
----------------------------------------------------------res
                             c --(3)

-------------andn
b ^ c, ~b, ~c      (2)  (3)
---------------------------res
           b ^ c --(4)

-----------------------asmp  -------------------------------------andp
a ^ b ^ c ^ (x v y v c)      ~(a ^ b ^ c ^ (x v y v z)), x v y v z
------------------------------------------------------------------res  ---------------------orp
                             x v y v z                                 ~(x v y v z), x, y, z 
                             ---------------------------------------------------------------res
                                                         x, y, z --(5)

---------------orn  -------(5)  ---------orn  ---------orn  --------------------orn
x v (y v z), ~x     x, y, z     y v z, ~y     y v z, ~z     x v (y v z), ~(y v z)
---------------------------------------------------------------------------------res
                                    x v (y v z) --(6)

---------------------------------------------------------andn  --(1)  -----(4)  ----------(6)
a ^ (b ^ c) ^ (x v (y v z)), ~a, ~(b ^ c), ~(x v (y v z))      a      b ^ c     x v (y v z)
-------------------------------------------------------------------------------------------res
                             a ^ (b ^ c) ^ (x v (y v z))

LTR:
---------------------------asmp  ---------------------------------andp
a ^ (b ^ c) ^ (x v (y v z))      ~(a ^ (b ^ c) ^ (x v (y v z))), a
------------------------------------------------------------------res
                                 a --(1)

---------------------------asmp  -------------------------------------andp
a ^ (b ^ c) ^ (x v (y v z))      ~(a ^ (b ^ c) ^ (x v (y v z))), b ^ c
------------------------------------------------------------------res
                                 b ^ c --(2)

-----------andp  -----(2)
~(b ^ c), b      b ^ c
----------------------res
           b --(3)

-----------andp  -----(2)
~(b ^ c), c      b ^ c
----------------------res
           c --(4)

---------------------------asmp  -------------------------------------------andp
a ^ (b ^ c) ^ (x v (y v z))      ~(a ^ (b ^ c) ^ (x v (y v z))), x v (y v z)
----------------------------------------------------------------------------res
                                 x v (y v z) --(5)

------------------------orp  -----------(5)
~(x v (y v z)), x, y v z     x v (y v z)
----------------------------------------res  --------------orp
                x, y v z                     ~(y v z), y, z
                -------------------------------------------res  -------------orn  -------------orn  -------------orn
                                  x, y, z                       x v y v z, ~x     x v y v z, ~y     x v y v z, ~z
                                  -------------------------------------------------------------------------------res
                                                                      x v y v z --(6)

-------------------------------------------------andn  --(1)  --(3)  --(4)  ---------(6)
a ^ b ^ c ^ (x v y v z), ~a, ~b, ~c, ~(x v y v z)      a      b      c      x v y v z
-------------------------------------------------------------------------------------res
                             a ^ b ^ c ^ (x v y v z)

-------ac_simp
a <-> b

a
--ImmFlatten
b

b
--ImmFlatten
a

-----Flatten
~a, b 

-----Flatten
~b, a

-------------eqn2  ---------orn  ---------orn
a, b, a <-> b      a v b, ~a     a v b, ~b
------------------------------------------res
                a v b, a <-> b

Encode:
-------ac_simp
a <-> b

into:
-------------eqn2  -----Flatten  ---------------eqn1  -----Flatten
a, b, a <-> b      ~b, a         ~a, ~b, a <-> b      ~a, b
------------------------res      --------------------------res
       a, a <-> b                       ~a, a <-> b
       --------------------------------------------res
                          a <-> b

Eqcongp
=======
Encode:
------------------------------------
~(x = y), ~(a = b), (P x a) = (P y b)

into:
----------------------------------eqcngp  ---------------------------eqn2
~(x = y), ~(a = b), ~(P x a), P y b        P x a = P y b, P x a, P y b
-------------------------------------------------------------------------res
              ~(x = y), ~(a = b), P x a = P y b, P y b --(1)

------------------------------------eqcngp  ---------------------------------eqn1
~(x = y), ~(a = b), ~(P y b), P x a         P x a = P y b, ~(P x a), ~(P y b)
-----------------------------------------------------------------------------res
              ~(x = y), ~(a = b), P x a = P y b, ~(P y b) --(2)

(t7, SumsimpAST, (cl  ((((2 * op_2) + 1) = (1 + (2 * op_2))))), [], [])


	(2 * op_2) + 1 = 1 + (2 * op_2)
--------------------------------------------------------cong
(2 * op_2 + 1 = 2 * op_3) = (2 * op_3 = 1 + 2 * op_2)

        (1)             (2)
-------------------------------------
~(x = y), ~(a = b), (P x a) = (P y b)


(x8, Equn1AST, (cl  (((2 * op_3) = (2 * op_3))) ((2 * op_3))), [], [])
(x9, Equn2AST, (cl  (((2 * op_3) = (2 * op_3))) ((not (2 * op_3)))), [], [])
(x7, ResoAST, (cl  (((2 * op_3) = (2 * op_3)))), [ x8 x9], [])
(x10, EqcpAST, (cl  ((not ((2 * op_3) = (2 * op_3)))) ((not (((2 * op_2) + 1) = (1 + (2 * op_2))))) ((not (((2 * op_2) + 1) = (2 * op_3)))) (((2 * op_3) = (1 + (2 * op_2))))), [], [])
(x12, Equn2AST, (cl  (((((2 * op_2) + 1) = (2 * op_3)) = ((2 * op_3) = (1 + (2 * op_2))))) ((((2 * op_2) + 1) = (2 * op_3))) (((2 * op_3) = (1 + (2 * op_2))))), [], [])
(x14, ResoAST, (cl  ((not ((2 * op_3) = (2 * op_3)))) ((not (((2 * op_2) + 1) = (1 + (2 * op_2))))) (((((2 * op_2) + 1) = (2 * op_3)) = ((2 * op_3) = (1 + (2 * op_2))))) (((2 * op_3) = (1 + (2 * op_2))))), [ x10 x12], [])
(x11, EqcpAST, (cl  ((not ((2 * op_3) = (2 * op_3)))) ((not (((2 * op_2) + 1) = (1 + (2 * op_2))))) ((not ((2 * op_3) = (1 + (2 * op_2))))) ((((2 * op_2) + 1) = (2 * op_3)))), [], [])
(x13, Equn1AST, (cl  (((((2 * op_2) + 1) = (2 * op_3)) = ((2 * op_3) = (1 + (2 * op_2))))) ((not (((2 * op_2) + 1) = (2 * op_3)))) ((not ((2 * op_3) = (1 + (2 * op_2)))))), [], [])
(x15, ResoAST, (cl  ((not ((2 * op_3) = (2 * op_3)))) ((not (((2 * op_2) + 1) = (1 + (2 * op_2))))) (((((2 * op_2) + 1) = (2 * op_3)) = ((2 * op_3) = (1 + (2 * op_2))))) ((not ((2 * op_3) = (1 + (2 * op_2)))))), [ x11 x13], [])
(t10, ResoAST, (cl  (((((2 * op_2) + 1) = (2 * op_3)) = ((2 * op_3) = (1 + (2 * op_2)))))), [ x14 x15 x7 t7], [])


Cong Rule
=========
  x1 = y1 ... xn = yn
-------------------------
F x1 ... xn = F y1 ... yn

1. When F is equality/iff
    x = a   y = b
  -----------------
  (x = y) = (a = b)
  Find implicit premise modulo symmetry, so for (x = y) = (a = b), one premise could be x = a, a = x, x = b or b = x
  and the other could be y = b, b = y, y = a, or a = y
  (i) if x, y, a, b are bools, then encode using connective rules of iff 
      (and encode implicit premises using eqn1, eqn2, reso)
  (ii) if x, y, a, b are non-bools, then encode using eq_cong_pred
      (and encode implicit premises using refl)

For the next two cases, find implicit premises, and 
  if the premise is an equality over (non-bool) terms, then 
    implement using refl
  else (if the premise is an iff over bool formulas)
    implement using eqn1, eqn2, reso

2. When F is a (non-bool) function, 
  use eq_cong
  ----------------------------------------------------eqcong  -------     -------
  ~(x1 = y1), ... ~(xn = yn), (f x1 .. xn = f y1 .. yn)       x1 = y1 ... xn = yn
  -------------------------------------------------------------------------------res
                            f x1 .. xn = f y1 .. yn

3. When F is a (bool) predicate, 
  (i) if F is and, or, implies, xor, ite, not
        use connective intro and elimination rules to encode special cases
  (ii) for other cases (predicates over integers, user defined predicates) use eq_cong_pred