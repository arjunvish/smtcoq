For each *.smt2 file (filename.smt2),
- Call cvc5-rare on filename.smt2 with options and dump output to filename.smt2.cvc5prf
`cvc5 filename.smt2 --dump-proofs --proof-format-mode=alethe --proof-granularity=dsl-rewrite --dag-thresh=0` 
- Create filename.v and inside it call Verit_checker on filename.smt2 and filename.proof
- Add a subsection in benchmarks.v, print the name of the file, and a call to Verit_checker on filename

--test1
(assume a0 (and true (not true)))
(step t1 (cl (not (= (and true (not true)) false)) (not (and true (not true))) false) :rule equiv_pos2)
(step t2 (cl (= (and true (not true)) false)) :rule all_simplify :args (evaluate))
(step t3 (cl (= (not true) false)) :rule all_simplify :args (evaluate))
(step t4 (cl (= false (not true))) :rule symm :premises (t3))
(step t5 (cl (= (and true (not true)) (not true))) :rule trans :premises (t2 t4))
(step t6 (cl (= (not true) false)) :rule all_simplify :args (evaluate))
(step t7 (cl (= (and true (not true)) false)) :rule trans :premises (t5 t6))
(step t8 (cl false) :rule resolution :premises (t1 t7 a0))
(step t9 (cl (not false)) :rule false)
(step t10 (cl) :rule resolution :premises (t8 t9))

--test2
(assume a0 (not (or true false)))
(step t1 (cl (not (= (not (or true false)) false)) (not (not (or true false))) false) :rule equiv_pos2)
(step t2 (cl (= (or true false) true)) :rule all_simplify :args (evaluate))
(step t3 (cl (= (not (or true false)) (not true))) :rule cong :premises (t2))
(step t4 (cl (= (not true) false)) :rule all_simplify :args (evaluate))
(step t5 (cl (= (not (or true false)) false)) :rule trans :premises (t3 t4))
(step t6 (cl false) :rule resolution :premises (t1 t5 a0))
(step t7 (cl (not false)) :rule false)
(step t8 (cl) :rule resolution :premises (t6 t7))

--test3
(assume a0 (and op_0 (not op_0)))
(step t1 (cl op_0) :rule and :premises (a0))
(step t2 (cl (not op_0)) :rule and :premises (a0))
(step t3 (cl) :rule resolution :premises (t1 t2))

--test4
(assume a0 (and (or op_0 op_2 op_1) (or (not op_0) (not op_2) (not op_1)) (or (not op_0) op_2) (or (not op_2) op_1) (or (not op_1) op_0)))
(step t1 (cl (or op_0 op_2 op_1)) :rule and :premises (a0))
(step t2 (cl op_0 op_2 op_1) :rule or :premises (t1))
(step t3 (cl op_1 op_0 op_2) :rule reordering :premises (t2))
(step t4 (cl (or (not op_2) op_1)) :rule and :premises (a0))
(step t5 (cl (not op_2) op_1) :rule or :premises (t4))
(step t6 (cl op_1 (not op_2)) :rule reordering :premises (t5))
(step t7 (cl (or (not op_1) op_0)) :rule and :premises (a0))
(step t8 (cl (not op_1) op_0) :rule or :premises (t7))
(step t9 (cl op_0 (not op_1)) :rule reordering :premises (t8))
(step t10 (cl (or (not op_0) (not op_2) (not op_1))) :rule and :premises (a0))
(step t11 (cl (not op_0) (not op_2) (not op_1)) :rule or :premises (t10))
(step t12 (cl (not op_2) (not op_0) (not op_2)) :rule resolution :premises (t6 t11))
(step t13 (cl (not op_2) (not op_0)) :rule contraction :premises (t12))
(step t14 (cl (or (not op_0) op_2)) :rule and :premises (a0))
(step t15 (cl (not op_0) op_2) :rule or :premises (t14))
(step t16 (cl op_2 (not op_0)) :rule reordering :premises (t15))
(step t17 (cl (not op_0) (not op_0)) :rule resolution :premises (t13 t16))
(step t18 (cl (not op_0)) :rule contraction :premises (t17))
(step t19 (cl (not op_1)) :rule resolution :premises (t9 t18))
(step t20 (cl (not op_2)) :rule resolution :premises (t6 t19))
(step t21 (cl) :rule resolution :premises (t3 t20 t19 t18))

--test5
(assume a0 (not (or op_0 (not op_0))))
(step t1 (cl (not (not (not op_0))) op_0) :rule not_not)
(step t2 (cl (not (not op_0))) :rule not_or :premises (a0))
(step t3 (cl op_0) :rule resolution :premises (t1 t2))
(step t4 (cl (not op_0)) :rule not_or :premises (a0))
(step t5 (cl) :rule resolution :premises (t3 t4))

--test6
(assume a0 (not (or (not (= (op_3 op_2) op_0)) (not (op_1 (op_3 op_2))) (op_1 op_0))))
(step t1 (cl (not (= (not (or (not (= (op_3 op_2) op_0)) (not (op_1 (op_3 op_2))) (op_1 op_0))) (not (or (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2)))))) (not (not (or (not (= (op_3 op_2) op_0)) (not (op_1 (op_3 op_2))) (op_1 op_0)))) (not (or (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2))))) :rule equiv_pos2)
(step t2 (cl (= (= (op_3 op_2) op_0) (= op_0 (op_3 op_2)))) :rule hole :args (ARITH_POLY_NORM (= (= (op_3 op_2) op_0) (= op_0 (op_3 op_2)))))
(step t3 (cl (= (not (= (op_3 op_2) op_0)) (not (= op_0 (op_3 op_2))))) :rule cong :premises (t2))
(step t4 (cl (= (not (op_1 (op_3 op_2))) (not (op_1 (op_3 op_2))))) :rule refl)
(step t5 (cl (= (op_1 op_0) (op_1 op_0))) :rule refl)
(step t6 (cl (= (or (not (= (op_3 op_2) op_0)) (not (op_1 (op_3 op_2))) (op_1 op_0)) (or (not (= op_0 (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 op_0)))) :rule cong :premises (t3 t4 t5))
(step t7 (cl (= (not (or (not (= (op_3 op_2) op_0)) (not (op_1 (op_3 op_2))) (op_1 op_0))) (not (or (not (= op_0 (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 op_0))))) :rule cong :premises (t6))
(step t8 (cl (not (not (not (= op_0 (op_3 op_2))))) (= op_0 (op_3 op_2))) :rule not_not)
(step t9 (cl (not (= (not (or (not (= (op_3 op_2) op_0)) (not (op_1 (op_3 op_2))) (op_1 op_0))) (not (or (not (= op_0 (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 op_0))))) (not (not (or (not (= (op_3 op_2) op_0)) (not (op_1 (op_3 op_2))) (op_1 op_0)))) (not (or (not (= op_0 (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 op_0)))) :rule equiv_pos2)
(step t10 (cl (not (or (not (= op_0 (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 op_0)))) :rule resolution :premises (t9 t7 a0))
(step t11 (cl (not (not (= op_0 (op_3 op_2))))) :rule not_or :premises (t10))
(step t12 (cl (= op_0 (op_3 op_2))) :rule resolution :premises (t8 t11))
(step t13 (cl (= (op_3 op_2) (op_3 op_2))) :rule refl)
(step t14 (cl (= (= op_0 (op_3 op_2)) (= (op_3 op_2) (op_3 op_2)))) :rule cong :premises (t12 t13))
(step t15 (cl (= (not (= op_0 (op_3 op_2))) (not (= (op_3 op_2) (op_3 op_2))))) :rule cong :premises (t14))
(step t16 (cl (= (not (op_1 (op_3 op_2))) (not (op_1 (op_3 op_2))))) :rule refl)
(step t17 (cl (= (op_1 op_0) (op_1 (op_3 op_2)))) :rule cong :premises (t12))
(step t18 (cl (= (or (not (= op_0 (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 op_0)) (or (not (= (op_3 op_2) (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2))))) :rule cong :premises (t15 t16 t17))
(step t19 (cl (= (not (or (not (= op_0 (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 op_0))) (not (or (not (= (op_3 op_2) (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2)))))) :rule cong :premises (t18))
(step t20 (cl (= (= (op_3 op_2) (op_3 op_2)) true)) :rule all_simplify :args (eq_simplify1 (op_3 op_2)))
(step t21 (cl (= (not (= (op_3 op_2) (op_3 op_2))) (not true))) :rule cong :premises (t20))
(step t22 (cl (= (not true) false)) :rule all_simplify :args (evaluate))
(step t23 (cl (= (not (= (op_3 op_2) (op_3 op_2))) false)) :rule trans :premises (t21 t22))
(step t24 (cl (= (op_1 (op_3 op_2)) (op_1 (op_3 op_2)))) :rule refl)
(step t25 (cl (= (or (not (= (op_3 op_2) (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2))) (or false (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2))))) :rule cong :premises (t23 t4 t24))
(step t26 (cl (= (or false (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2))) (or (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2))))) :rule all_simplify :args (or_simplify2 (cvc5_nary_op) (cvc5_nary_op (not (op_1 (op_3 op_2))))))
(step t27 (cl (= (or (not (= (op_3 op_2) (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2))) (or (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2))))) :rule trans :premises (t25 t26))
(step t28 (cl (= (not (or (not (= (op_3 op_2) (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2)))) (not (or (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2)))))) :rule cong :premises (t27))
(step t29 (cl (= (not (or (not (= op_0 (op_3 op_2))) (not (op_1 (op_3 op_2))) (op_1 op_0))) (not (or (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2)))))) :rule trans :premises (t19 t28))
(step t30 (cl (= (not (or (not (= (op_3 op_2) op_0)) (not (op_1 (op_3 op_2))) (op_1 op_0))) (not (or (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2)))))) :rule trans :premises (t7 t29))
(step t31 (cl (not (or (not (op_1 (op_3 op_2))) (op_1 (op_3 op_2))))) :rule resolution :premises (t1 t30 a0))
(step t32 (cl (not (op_1 (op_3 op_2)))) :rule not_or :premises (t31))
(step t33 (cl (not (not (not (op_1 (op_3 op_2))))) (op_1 (op_3 op_2))) :rule not_not)
(step t34 (cl (not (not (op_1 (op_3 op_2))))) :rule not_or :premises (t31))
(step t35 (cl (op_1 (op_3 op_2))) :rule resolution :premises (t33 t34))
(step t36 (cl) :rule resolution :premises (t32 t35))

--test7
(assume a0 (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))
(step t1 (cl (not (= (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) (not (=> (ite op_0 (and op_1 (= op_2 op_3)) (and (not op_1) (= op_2 op_3))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))) (not (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) (not (=> (ite op_0 (and op_1 (= op_2 op_3)) (and (not op_1) (= op_2 op_3))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) :rule equiv_pos2)
(step t2 (cl (= op_0 op_0)) :rule refl)
(step t3 (cl (= op_1 op_1)) :rule refl)
(step t4 (cl (= (+ (* 2 op_2) 1) (+ 1 (* 2 op_2)))) :rule hole :args (ARITH_POLY_NORM (= (+ (* 2 op_2) 1) (+ 1 (* 2 op_2)))))
(step t5 (cl (= (+ (* 2 op_3) 1) (+ 1 (* 2 op_3)))) :rule hole :args (ARITH_POLY_NORM (= (+ (* 2 op_3) 1) (+ 1 (* 2 op_3)))))
(step t6 (cl (= (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))))) :rule cong :premises (t4 t5))
(step t7 (cl (= (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= op_2 op_3))) :rule hole :args (ARITH_POLY_NORM (= (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= op_2 op_3))))
(step t8 (cl (= (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= op_2 op_3))) :rule trans :premises (t6 t7))
(step t9 (cl (= (* 2 op_3) (* 2 op_3))) :rule refl)
(step t10 (cl (= (= (+ (* 2 op_2) 1) (* 2 op_3)) (= (+ 1 (* 2 op_2)) (* 2 op_3)))) :rule cong :premises (t4 t9))
(step t11 (cl (= (= (+ 1 (* 2 op_2)) (* 2 op_3)) false)) :rule all_simplify)
(step t12 (cl (= (= (+ (* 2 op_2) 1) (* 2 op_3)) false)) :rule trans :premises (t10 t11))
(step t13 (cl (= (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= op_2 op_3) false))) :rule cong :premises (t3 t8 t12))
(step t14 (cl (= (ite op_1 (= op_2 op_3) false) (and op_1 (= op_2 op_3)))) :rule all_simplify :args (ite_simplify10 op_1 (= op_2 op_3)))
(step t15 (cl (= (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (and op_1 (= op_2 op_3)))) :rule trans :premises (t13 t14))
(step t16 (cl (= (* 2 op_2) (* 2 op_2))) :rule refl)
(step t17 (cl (= (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (+ 1 (* 2 op_3))))) :rule cong :premises (t16 t5))
(step t18 (cl (= (= (* 2 op_2) (+ 1 (* 2 op_3))) false)) :rule all_simplify)
(step t19 (cl (= (= (* 2 op_2) (+ (* 2 op_3) 1)) false)) :rule trans :premises (t17 t18))
(step t20 (cl (= (= (* 2 op_2) (* 2 op_3)) (= op_2 op_3))) :rule hole :args (ARITH_POLY_NORM (= (= (* 2 op_2) (* 2 op_3)) (= op_2 op_3))))
(step t21 (cl (= (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3))) (ite op_1 false (= op_2 op_3)))) :rule cong :premises (t3 t19 t20))
(step t22 (cl (= (ite op_1 false (= op_2 op_3)) (and (not op_1) (= op_2 op_3)))) :rule all_simplify :args (ite_simplify11 op_1 (= op_2 op_3)))
(step t23 (cl (= (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3))) (and (not op_1) (= op_2 op_3)))) :rule trans :premises (t21 t22))
(step t24 (cl (= (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (ite op_0 (and op_1 (= op_2 op_3)) (and (not op_1) (= op_2 op_3))))) :rule cong :premises (t2 t15 t23))
(step t25 (cl (= (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) :rule refl)
(step t26 (cl (= (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))) (=> (ite op_0 (and op_1 (= op_2 op_3)) (and (not op_1) (= op_2 op_3))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) :rule cong :premises (t24 t25))
(step t27 (cl (= (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) (not (=> (ite op_0 (and op_1 (= op_2 op_3)) (and (not op_1) (= op_2 op_3))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))) :rule cong :premises (t26))
(step t28 (cl (not (=> (ite op_0 (and op_1 (= op_2 op_3)) (and (not op_1) (= op_2 op_3))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) :rule resolution :premises (t1 t27 a0))
(step t29 (cl (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) :rule not_implies2 :premises (t28))
(step t30 (cl (not (=> op_0 op_1)) (not (=> op_1 op_0)) (not (= op_2 op_3))) :rule not_and :premises (t29))
(step t31 (cl (not (= op_2 op_3)) (not (=> op_0 op_1)) (not (=> op_1 op_0))) :rule reordering :premises (t30))
(step t32 (cl (=> op_1 op_0) op_1) :rule implies_neg1)
(step t33 (cl op_1 (=> op_1 op_0)) :rule reordering :premises (t32))
(step t34 (cl (not (and (not op_1) (= op_2 op_3))) (not op_1)) :rule and_pos)
(step t35 (cl (not op_1) (not (and (not op_1) (= op_2 op_3)))) :rule reordering :premises (t34))
(step t36 (cl (ite op_0 (and op_1 (= op_2 op_3)) (and (not op_1) (= op_2 op_3)))) :rule not_implies1 :premises (t28))
(step t37 (cl op_0 (and (not op_1) (= op_2 op_3))) :rule ite1 :premises (t36))
(step t38 (cl (=> op_0 op_1) (not op_1)) :rule implies_neg2)
(step t39 (cl (not (and op_1 (= op_2 op_3))) (= op_2 op_3)) :rule and_pos)
(step t40 (cl (= op_2 op_3) (not (and op_1 (= op_2 op_3)))) :rule reordering :premises (t39))
(step t41 (cl (not (and op_1 (= op_2 op_3))) op_1) :rule and_pos)
(step t42 (cl op_1 (not (and op_1 (= op_2 op_3)))) :rule reordering :premises (t41))
(step t43 (cl (=> op_1 op_0) (not op_0)) :rule implies_neg2)
(step t44 (cl (not (and op_1 (= op_2 op_3))) (not (and op_1 (= op_2 op_3))) (not op_0)) :rule resolution :premises (t31 t38 t40 t42 t43))
(step t45 (cl (not (and op_1 (= op_2 op_3))) (not op_0)) :rule contraction :premises (t44))
(step t46 (cl (not op_0) (and op_1 (= op_2 op_3))) :rule ite2 :premises (t36))
(step t47 (cl (and op_1 (= op_2 op_3)) (not op_0)) :rule reordering :premises (t46))
(step t48 (cl (not op_0) (not op_0)) :rule resolution :premises (t45 t47))
(step t49 (cl (not op_0)) :rule contraction :premises (t48))
(step t50 (cl (and (not op_1) (= op_2 op_3))) :rule resolution :premises (t37 t49))
(step t51 (cl (not op_1)) :rule resolution :premises (t35 t50))
(step t52 (cl (=> op_1 op_0)) :rule resolution :premises (t33 t51))
(step t53 (cl (not (and (not op_1) (= op_2 op_3))) (= op_2 op_3)) :rule and_pos)
(step t54 (cl (= op_2 op_3) (not (and (not op_1) (= op_2 op_3)))) :rule reordering :premises (t53))
(step t55 (cl (= op_2 op_3)) :rule resolution :premises (t54 t50))
(step t56 (cl (=> op_0 op_1) op_0) :rule implies_neg1)
(step t57 (cl op_0 (=> op_0 op_1)) :rule reordering :premises (t56))
(step t58 (cl (=> op_0 op_1)) :rule resolution :premises (t57 t49))
(step t59 (cl) :rule resolution :premises (t31 t52 t55 t58))

--test8
(assume a0 (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1))))))
(step t1 (cl (not (= (not (= (op_2 op_1) (op_2 (+ (- 1) op_0)))) false)) (not (not (= (op_2 op_1) (op_2 (+ (- 1) op_0))))) false) :rule equiv_pos2)
(step t2 (cl (not (= (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0))))))) (not (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1)))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule equiv_pos2)
(step t3 (cl (= op_0 op_0)) :rule refl)
(step t4 (cl (= (+ op_1 1) (+ 1 op_1))) :rule hole :args (ARITH_POLY_NORM (= (+ op_1 1) (+ 1 op_1))))
(step t5 (cl (= (= op_0 (+ op_1 1)) (= op_0 (+ 1 op_1)))) :rule cong :premises (t3 t4))
(step t6 (cl (= (= op_0 (+ 1 op_1)) (= op_1 (+ (- 1) op_0)))) :rule hole :args (ARITH_POLY_NORM (= (= op_0 (+ 1 op_1)) (= op_1 (+ (- 1) op_0)))))
(step t7 (cl (= (= op_0 (+ op_1 1)) (= op_1 (+ (- 1) op_0)))) :rule trans :premises (t5 t6))
(step t8 (cl (= (op_2 op_1) (op_2 op_1))) :rule refl)
(step t9 (cl (= (- op_0 1) (+ op_0 (* (- 1) 1)))) :rule hole :args (ARITH_POLY_NORM (= (- op_0 1) (+ op_0 (* (- 1) 1)))))
(step t10 (cl (= (* (- 1) 1) (- 1))) :rule all_simplify :args (evaluate))
(step t11 (cl (= (+ op_0 (* (- 1) 1)) (+ op_0 (- 1)))) :rule cong :premises (t3 t10))
(step t12 (cl (= (+ op_0 (- 1)) (+ (- 1) op_0))) :rule hole :args (ARITH_POLY_NORM (= (+ op_0 (- 1)) (+ (- 1) op_0))))
(step t13 (cl (= (+ op_0 (* (- 1) 1)) (+ (- 1) op_0))) :rule trans :premises (t11 t12))
(step t14 (cl (= (- op_0 1) (+ (- 1) op_0))) :rule trans :premises (t9 t13))
(step t15 (cl (= (op_2 (- op_0 1)) (op_2 (+ (- 1) op_0)))) :rule cong :premises (t14))
(step t16 (cl (= (= (op_2 op_1) (op_2 (- op_0 1))) (= (op_2 op_1) (op_2 (+ (- 1) op_0))))) :rule cong :premises (t8 t15))
(step t17 (cl (= (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1)))) (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule cong :premises (t7 t16))
(step t18 (cl (= (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0))))))) :rule cong :premises (t17))
(step t19 (cl (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule resolution :premises (t2 t18 a0))
(step t20 (cl (= op_1 (+ (- 1) op_0))) :rule not_implies1 :premises (t19))
(step t21 (cl (= (op_2 op_1) (op_2 (+ (- 1) op_0)))) :rule cong :premises (t20))
(step t22 (cl (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0)))) :rule refl)
(step t23 (cl (= (= (op_2 op_1) (op_2 (+ (- 1) op_0))) (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0))))) :rule cong :premises (t21 t22))
(step t24 (cl (= (not (= (op_2 op_1) (op_2 (+ (- 1) op_0)))) (not (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0)))))) :rule cong :premises (t23))
(step t25 (cl (= (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0))) true)) :rule all_simplify :args (eq_simplify1 (op_2 (+ (- 1) op_0))))
(step t26 (cl (= (not (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0)))) (not true))) :rule cong :premises (t25))
(step t27 (cl (= (not true) false)) :rule all_simplify :args (evaluate))
(step t28 (cl (= (not (= (op_2 (+ (- 1) op_0)) (op_2 (+ (- 1) op_0)))) false)) :rule trans :premises (t26 t27))
(step t29 (cl (= (not (= (op_2 op_1) (op_2 (+ (- 1) op_0)))) false)) :rule trans :premises (t24 t28))
(step t30 (cl (not (= (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0))))))) (not (not (=> (= op_0 (+ op_1 1)) (= (op_2 op_1) (op_2 (- op_0 1)))))) (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule equiv_pos2)
(step t31 (cl (not (=> (= op_1 (+ (- 1) op_0)) (= (op_2 op_1) (op_2 (+ (- 1) op_0)))))) :rule resolution :premises (t30 t18 a0))
(step t32 (cl (not (= (op_2 op_1) (op_2 (+ (- 1) op_0))))) :rule not_implies2 :premises (t31))
(step t33 (cl false) :rule resolution :premises (t1 t29 t32))
(step t34 (cl (not false)) :rule false)
(step t35 (cl) :rule resolution :premises (t33 t34))

--test9.smt2
(assume a0 (= x y))
(assume a1 (= a b))
(assume a2 (not (= (and x true a) (and y true b))))
(step t1 (cl (not (= (not (= (and x true a) (and y true b))) false)) (not (not (= (and x true a) (and y true b)))) false) :rule equiv_pos2)
(step t2 (cl (= (and x true a) (and x a))) :rule all_simplify :args (and_simplify2 (cvc5_nary_op x) (cvc5_nary_op a)))
(step t3 (cl (= (and y true b) (and y b))) :rule all_simplify :args (and_simplify2 (cvc5_nary_op y) (cvc5_nary_op b)))
(step t4 (cl (= (= (and x true a) (and y true b)) (= (and x a) (and y b)))) :rule cong :premises (t2 t3))
(step t5 (cl (= (not (= (and x true a) (and y true b))) (not (= (and x a) (and y b))))) :rule cong :premises (t4))
(step t6 (cl (and (= a b) (= x y)) (not (= a b)) (not (= x y))) :rule and_neg)
(step t7 (cl (and (= a b) (= x y))) :rule resolution :premises (t6 a1 a0))
(step t8 (cl (= x y)) :rule and :premises (t7))
(step t9 (cl (= a b)) :rule and :premises (t7))
(step t10 (cl (= (and x a) (and y b))) :rule cong :premises (t8 t9))
(step t11 (cl (= (and y b) (and y b))) :rule refl)
(step t12 (cl (= (= (and x a) (and y b)) (= (and y b) (and y b)))) :rule cong :premises (t10 t11))
(step t13 (cl (= (not (= (and x a) (and y b))) (not (= (and y b) (and y b))))) :rule cong :premises (t12))
(step t14 (cl (= (= (and y b) (and y b)) (and (=> (and y b) (and y b)) (=> (and y b) (and y b))))) :rule all_simplify :args (connective_def2 (and y b) (and y b)))
(step t15 (cl (= (and (=> (and y b) (and y b)) (=> (and y b) (and y b))) (=> (and y b) (and y b)))) :rule all_simplify :args (and_simplify3 (=> (and y b) (and y b)) (cvc5_nary_op) (cvc5_nary_op) (cvc5_nary_op)))
(step t16 (cl (= (=> (and y b) (and y b)) true)) :rule all_simplify :args (implies_simplify6 (and y b)))
(step t17 (cl (= (and (=> (and y b) (and y b)) (=> (and y b) (and y b))) true)) :rule trans :premises (t15 t16))
(step t18 (cl (= (= (and y b) (and y b)) true)) :rule trans :premises (t14 t17))
(step t19 (cl (= (not (= (and y b) (and y b))) (not true))) :rule cong :premises (t18))
(step t20 (cl (= (not true) false)) :rule all_simplify :args (evaluate))
(step t21 (cl (= (not (= (and y b) (and y b))) false)) :rule trans :premises (t19 t20))
(step t22 (cl (= (not (= (and x a) (and y b))) false)) :rule trans :premises (t13 t21))
(step t23 (cl (= (not (= (and x true a) (and y true b))) false)) :rule trans :premises (t5 t22))
(step t24 (cl false) :rule resolution :premises (t1 t23 a2))
(step t25 (cl (not false)) :rule false)
(step t26 (cl) :rule resolution :premises (t24 t25))
