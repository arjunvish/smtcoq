(assume a0 (not thesis_d))
(assume a1 (=> (<= e2_d e1_d) thesis_d))
(assume a2 (=> (<= e1_d e2_d) thesis_d))
(step t1 (cl (not (= (or (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1))) (or (>= (+ e1_d (* (- 1) e2_d)) 0) (not (>= (+ e1_d (* (- 1) e2_d)) 1))))) (not (or (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) (or (>= (+ e1_d (* (- 1) e2_d)) 0) (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule equiv_pos2)
(step t2 (cl (= (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (>= (+ e1_d (* (- 1) e2_d)) 0))) :rule all_simplify :args (not_simplify1 (>= (+ e1_d (* (- 1) e2_d)) 0)))
(step t3 (cl (= (not (>= (+ e1_d (* (- 1) e2_d)) 1)) (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule refl)
(step t4 (cl (= (or (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1))) (or (>= (+ e1_d (* (- 1) e2_d)) 0) (not (>= (+ e1_d (* (- 1) e2_d)) 1))))) :rule cong :premises (t2 t3))
(step t5 (cl (=> (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)) false) (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule implies_neg1)
(anchor :step t6)
(assume t6.a0 (not (>= (+ e1_d (* (- 1) e2_d)) 0)))
(assume t6.a1 (>= (+ e1_d (* (- 1) e2_d)) 1))
(step t6.t1 (cl (not (= (< (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1))) false)) (not (< (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1)))) false) :rule equiv_pos2)
(step t6.t2 (cl (= (< (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1))) (not (>= (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1)))))) :rule all_simplify :args (arith-elim-lt (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1))))
(step t6.t3 (cl (= (* 1 (+ e1_d (* (- 1) e2_d))) (+ e1_d (* (- 1) e2_d)))) :rule hole :args (ARITH_POLY_NORM (= (* 1 (+ e1_d (* (- 1) e2_d))) (+ e1_d (* (- 1) e2_d)))))
(step t6.t4 (cl (= (* (- 1) (+ e1_d (* (- 1) e2_d))) (+ (* (- 1) e1_d) e2_d))) :rule hole :args (ARITH_POLY_NORM (= (* (- 1) (+ e1_d (* (- 1) e2_d))) (+ (* (- 1) e1_d) e2_d))))
(step t6.t5 (cl (= (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (+ e1_d (* (- 1) e2_d)) (+ (* (- 1) e1_d) e2_d)))) :rule cong :premises (t6.t3 t6.t4))
(step t6.t6 (cl (= (+ (+ e1_d (* (- 1) e2_d)) (+ (* (- 1) e1_d) e2_d)) 0)) :rule hole :args (ARITH_POLY_NORM (= (+ (+ e1_d (* (- 1) e2_d)) (+ (* (- 1) e1_d) e2_d)) 0)))
(step t6.t7 (cl (= (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) 0)) :rule trans :premises (t6.t5 t6.t6))
(step t6.t8 (cl (= (* 1 0) 0)) :rule prod_simplify)
(step t6.t9 (cl (= (* (- 1) 1) (- 1))) :rule prod_simplify)
(step t6.t10 (cl (= (+ (* 1 0) (* (- 1) 1)) (+ 0 (- 1)))) :rule cong :premises (t6.t8 t6.t9))
(step t6.t11 (cl (= (+ 0 (- 1)) (- 1))) :rule sum_simplify)
(step t6.t12 (cl (= (+ (* 1 0) (* (- 1) 1)) (- 1))) :rule trans :premises (t6.t10 t6.t11))
(step t6.t13 (cl (= (>= (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1))) (>= 0 (- 1)))) :rule cong :premises (t6.t7 t6.t12))
(step t6.t14 (cl (= (>= 0 (- 1)) true)) :rule comp_simplify)
(step t6.t15 (cl (= (>= (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1))) true)) :rule trans :premises (t6.t13 t6.t14))
(step t6.t16 (cl (= (not (>= (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1)))) (not true))) :rule cong :premises (t6.t15))
(step t6.t17 (cl (= (not true) false)) :rule not_simplify)
(step t6.t18 (cl (= (not (>= (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1)))) false)) :rule trans :premises (t6.t16 t6.t17))
(step t6.t19 (cl (= (< (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1))) false)) :rule trans :premises (t6.t2 t6.t18))
(step t6.t20 (cl (not (< (* 1 (+ e1_d (* (- 1) e2_d))) (* 1 0))) (not (<= (* (- 1) (+ e1_d (* (- 1) e2_d))) (* (- 1) 1))) (< (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1)))) :rule la_generic :args (1 1 1))
(step t6.t21 (cl (=> (and (> 1 0) (< (+ e1_d (* (- 1) e2_d)) 0)) (< (* 1 (+ e1_d (* (- 1) e2_d))) (* 1 0)))) :rule la_mult_pos)
(step t6.t22 (cl (not (and (> 1 0) (< (+ e1_d (* (- 1) e2_d)) 0))) (< (* 1 (+ e1_d (* (- 1) e2_d))) (* 1 0))) :rule implies :premises (t6.t21))
(step t6.t23 (cl (and (> 1 0) (< (+ e1_d (* (- 1) e2_d)) 0)) (not (> 1 0)) (not (< (+ e1_d (* (- 1) e2_d)) 0))) :rule and_neg)
(step t6.t24 (cl (= (= (> 1 0) true) (> 1 0))) :rule equiv_simplify)
(step t6.t25 (cl (not (= (> 1 0) true)) (> 1 0)) :rule equiv1 :premises (t6.t24))
(step t6.t26 (cl (= (> 1 0) true)) :rule comp_simplify)
(step t6.t27 (cl (> 1 0)) :rule resolution :premises (t6.t25 t6.t26))
(step t6.t28 (cl (not (= (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (< (+ e1_d (* (- 1) e2_d)) 0))) (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (< (+ e1_d (* (- 1) e2_d)) 0)) :rule equiv_pos2)
(step t6.t29 (cl (= (< (+ e1_d (* (- 1) e2_d)) 0) (not (>= (+ e1_d (* (- 1) e2_d)) 0)))) :rule all_simplify :args (arith-elim-lt (+ e1_d (* (- 1) e2_d)) 0))
(step t6.t30 (cl (= (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (< (+ e1_d (* (- 1) e2_d)) 0))) :rule symm :premises (t6.t29))
(step t6.t31 (cl (< (+ e1_d (* (- 1) e2_d)) 0)) :rule resolution :premises (t6.t28 t6.t30 t6.a0))
(step t6.t32 (cl (and (> 1 0) (< (+ e1_d (* (- 1) e2_d)) 0))) :rule resolution :premises (t6.t23 t6.t27 t6.t31))
(step t6.t33 (cl (< (* 1 (+ e1_d (* (- 1) e2_d))) (* 1 0))) :rule resolution :premises (t6.t22 t6.t32))
(step t6.t34 (cl (=> (and (< (- 1) 0) (>= (+ e1_d (* (- 1) e2_d)) 1)) (<= (* (- 1) (+ e1_d (* (- 1) e2_d))) (* (- 1) 1)))) :rule la_mult_neg)
(step t6.t35 (cl (not (and (< (- 1) 0) (>= (+ e1_d (* (- 1) e2_d)) 1))) (<= (* (- 1) (+ e1_d (* (- 1) e2_d))) (* (- 1) 1))) :rule implies :premises (t6.t34))
(step t6.t36 (cl (and (< (- 1) 0) (>= (+ e1_d (* (- 1) e2_d)) 1)) (not (< (- 1) 0)) (not (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule and_neg)
(step t6.t37 (cl (= (= (< (- 1) 0) true) (< (- 1) 0))) :rule equiv_simplify)
(step t6.t38 (cl (not (= (< (- 1) 0) true)) (< (- 1) 0)) :rule equiv1 :premises (t6.t37))
(step t6.t39 (cl (= (< (- 1) 0) true)) :rule comp_simplify)
(step t6.t40 (cl (< (- 1) 0)) :rule resolution :premises (t6.t38 t6.t39))
(step t6.t41 (cl (and (< (- 1) 0) (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule resolution :premises (t6.t36 t6.t40 t6.a1))
(step t6.t42 (cl (<= (* (- 1) (+ e1_d (* (- 1) e2_d))) (* (- 1) 1))) :rule resolution :premises (t6.t35 t6.t41))
(step t6.t43 (cl (< (+ (* 1 (+ e1_d (* (- 1) e2_d))) (* (- 1) (+ e1_d (* (- 1) e2_d)))) (+ (* 1 0) (* (- 1) 1)))) :rule resolution :premises (t6.t20 t6.t33 t6.t42))
(step t6.t44 (cl false) :rule resolution :premises (t6.t1 t6.t19 t6.t43))
(step t6 (cl (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1)) false) :rule subproof :discharge (t6.a0 t6.a1))
(step t7 (cl (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1))) (not (>= (+ e1_d (* (- 1) e2_d)) 0))) :rule and_pos)
(step t8 (cl (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1))) (>= (+ e1_d (* (- 1) e2_d)) 1)) :rule and_pos)
(step t9 (cl false (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1))) (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule resolution :premises (t6 t7 t8))
(step t10 (cl (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1))) (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1))) false) :rule reordering :premises (t9))
(step t11 (cl (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1))) false) :rule contraction :premises (t10))
(step t12 (cl (=> (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)) false) false) :rule resolution :premises (t5 t11))
(step t13 (cl (=> (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)) false) (not false)) :rule implies_neg2)
(step t14 (cl (=> (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)) false) (=> (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)) false)) :rule resolution :premises (t12 t13))
(step t15 (cl (=> (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)) false)) :rule contraction :premises (t14))
(step t16 (cl (= (=> (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)) false) (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1))))) :rule implies_simplify)
(step t17 (cl (not (=> (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)) false)) (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule equiv1 :premises (t16))
(step t18 (cl (not (and (not (>= (+ e1_d (* (- 1) e2_d)) 0)) (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule resolution :premises (t15 t17))
(step t19 (cl (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule not_and :premises (t18))
(step t20 (cl (or (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1))) (not (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))))) :rule or_neg)
(step t21 (cl (or (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1))) (not (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule or_neg)
(step t22 (cl (or (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1))) (or (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule resolution :premises (t19 t20 t21))
(step t23 (cl (or (not (not (>= (+ e1_d (* (- 1) e2_d)) 0))) (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule contraction :premises (t22))
(step t24 (cl (or (>= (+ e1_d (* (- 1) e2_d)) 0) (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule resolution :premises (t1 t4 t23))
(step t25 (cl (>= (+ e1_d (* (- 1) e2_d)) 0) (not (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule or :premises (t24))
(step t26 (cl (not (= (=> (<= e1_d e2_d) thesis_d) (>= (+ e1_d (* (- 1) e2_d)) 1))) (not (=> (<= e1_d e2_d) thesis_d)) (>= (+ e1_d (* (- 1) e2_d)) 1)) :rule equiv_pos2)
(step t27 (cl (= (<= e1_d e2_d) (not (>= e1_d (+ e2_d 1))))) :rule all_simplify :args (arith-leq-norm e1_d e2_d))
(step t28 (cl (= (>= e1_d (+ e2_d 1)) (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule hole :args (ARITH_POLY_NORM (= (>= e1_d (+ e2_d 1)) (>= (+ e1_d (* (- 1) e2_d)) 1))))
(step t29 (cl (= (not (>= e1_d (+ e2_d 1))) (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule cong :premises (t28))
(step t30 (cl (= (<= e1_d e2_d) (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule trans :premises (t27 t29))
(step t31 (cl (= thesis_d thesis_d)) :rule refl)
(step t32 (cl (= (=> (<= e1_d e2_d) thesis_d) (=> (not (>= (+ e1_d (* (- 1) e2_d)) 1)) thesis_d))) :rule cong :premises (t30 t31))
(step t33 (cl (= (not (>= (+ e1_d (* (- 1) e2_d)) 1)) (not (>= (+ e1_d (* (- 1) e2_d)) 1)))) :rule refl)
(step t34 (cl (not (= (not thesis_d) (= thesis_d false))) (not (not thesis_d)) (= thesis_d false)) :rule equiv_pos2)
(step t35 (cl (= (= thesis_d false) (not thesis_d))) :rule all_simplify :args (equiv_simplify8 thesis_d))
(step t36 (cl (= (not thesis_d) (= thesis_d false))) :rule symm :premises (t35))
(step t37 (cl (= thesis_d false)) :rule resolution :premises (t34 t36 a0))
(step t38 (cl (= (=> (not (>= (+ e1_d (* (- 1) e2_d)) 1)) thesis_d) (=> (not (>= (+ e1_d (* (- 1) e2_d)) 1)) false))) :rule cong :premises (t33 t37))
(step t39 (cl (= (=> (not (>= (+ e1_d (* (- 1) e2_d)) 1)) false) (not (not (>= (+ e1_d (* (- 1) e2_d)) 1))))) :rule all_simplify :args (implies_simplify5 (not (>= (+ e1_d (* (- 1) e2_d)) 1))))
(step t40 (cl (= (not (not (>= (+ e1_d (* (- 1) e2_d)) 1))) (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule all_simplify :args (not_simplify1 (>= (+ e1_d (* (- 1) e2_d)) 1)))
(step t41 (cl (= (=> (not (>= (+ e1_d (* (- 1) e2_d)) 1)) false) (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule trans :premises (t39 t40))
(step t42 (cl (= (=> (not (>= (+ e1_d (* (- 1) e2_d)) 1)) thesis_d) (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule trans :premises (t38 t41))
(step t43 (cl (= (=> (<= e1_d e2_d) thesis_d) (>= (+ e1_d (* (- 1) e2_d)) 1))) :rule trans :premises (t32 t42))
(step t44 (cl (>= (+ e1_d (* (- 1) e2_d)) 1)) :rule resolution :premises (t26 t43 a2))
(step t45 (cl (not (= (=> (<= e2_d e1_d) thesis_d) (not (>= (+ e1_d (* (- 1) e2_d)) 0)))) (not (=> (<= e2_d e1_d) thesis_d)) (not (>= (+ e1_d (* (- 1) e2_d)) 0))) :rule equiv_pos2)
(step t46 (cl (= (<= e2_d e1_d) (>= e1_d e2_d))) :rule all_simplify :args (arith-elim-leq e2_d e1_d))
(step t47 (cl (= (>= e1_d e2_d) (>= (+ e1_d (* (- 1) e2_d)) 0))) :rule hole :args (ARITH_POLY_NORM (= (>= e1_d e2_d) (>= (+ e1_d (* (- 1) e2_d)) 0))))
(step t48 (cl (= (<= e2_d e1_d) (>= (+ e1_d (* (- 1) e2_d)) 0))) :rule trans :premises (t46 t47))
(step t49 (cl (= (=> (<= e2_d e1_d) thesis_d) (=> (>= (+ e1_d (* (- 1) e2_d)) 0) thesis_d))) :rule cong :premises (t48 t31))
(step t50 (cl (= (>= (+ e1_d (* (- 1) e2_d)) 0) (>= (+ e1_d (* (- 1) e2_d)) 0))) :rule refl)
(step t51 (cl (not (= (not thesis_d) (= thesis_d false))) (not (not thesis_d)) (= thesis_d false)) :rule equiv_pos2)
(step t52 (cl (= (not thesis_d) (= thesis_d false))) :rule symm :premises (t35))
(step t53 (cl (= thesis_d false)) :rule resolution :premises (t51 t52 a0))
(step t54 (cl (= (=> (>= (+ e1_d (* (- 1) e2_d)) 0) thesis_d) (=> (>= (+ e1_d (* (- 1) e2_d)) 0) false))) :rule cong :premises (t50 t53))
(step t55 (cl (= (=> (>= (+ e1_d (* (- 1) e2_d)) 0) false) (not (>= (+ e1_d (* (- 1) e2_d)) 0)))) :rule all_simplify :args (implies_simplify5 (>= (+ e1_d (* (- 1) e2_d)) 0)))
(step t56 (cl (= (=> (>= (+ e1_d (* (- 1) e2_d)) 0) thesis_d) (not (>= (+ e1_d (* (- 1) e2_d)) 0)))) :rule trans :premises (t54 t55))
(step t57 (cl (= (=> (<= e2_d e1_d) thesis_d) (not (>= (+ e1_d (* (- 1) e2_d)) 0)))) :rule trans :premises (t49 t56))
(step t58 (cl (not (>= (+ e1_d (* (- 1) e2_d)) 0))) :rule resolution :premises (t45 t57 a1))
(step t59 (cl) :rule resolution :premises (t25 t44 t58))
