(assume a0 (not (= (not (= a_d b_d)) (or (and a_d (not b_d)) (and b_d (not a_d))))))
(step t1 (cl (not (or (and a_d (not b_d)) (and b_d (not a_d)))) (and a_d (not b_d)) (and b_d (not a_d))) :rule or_pos)
(step t2 (cl (and a_d (not b_d)) (and b_d (not a_d)) (not (or (and a_d (not b_d)) (and b_d (not a_d))))) :rule reordering :premises (t1))
(step t3 (cl (not (= a_d b_d)) (or (and a_d (not b_d)) (and b_d (not a_d)))) :rule not_equiv1 :premises (a0))
(step t4 (cl (= a_d b_d) a_d b_d) :rule equiv_neg2)
(step t5 (cl a_d b_d (= a_d b_d)) :rule reordering :premises (t4))
(step t6 (cl (not (and a_d (not b_d))) (not b_d)) :rule and_pos)
(step t7 (cl (not b_d) (not (and a_d (not b_d)))) :rule reordering :premises (t6))
(step t8 (cl (= a_d b_d) (not a_d) (not b_d)) :rule equiv_neg1)
(step t9 (cl (= a_d b_d) (not b_d) (not a_d)) :rule reordering :premises (t8))
(step t10 (cl (not (and b_d (not a_d))) (not a_d)) :rule and_pos)
(step t11 (cl (not a_d) (not (and b_d (not a_d)))) :rule reordering :premises (t10))
(step t12 (cl (not b_d) (not b_d) (not a_d) (not a_d)) :rule resolution :premises (t2 t3 t7 t9 t11))
(step t13 (cl (not b_d) (not a_d)) :rule contraction :premises (t12))
(step t14 (cl (or (and a_d (not b_d)) (and b_d (not a_d))) (not (and a_d (not b_d)))) :rule or_neg)
(step t15 (cl (not (= (or (not (not (= a_d b_d))) (not (or (and a_d (not b_d)) (and b_d (not a_d))))) (or (= a_d b_d) (not (or (and a_d (not b_d)) (and b_d (not a_d))))))) (not (or (not (not (= a_d b_d))) (not (or (and a_d (not b_d)) (and b_d (not a_d)))))) (or (= a_d b_d) (not (or (and a_d (not b_d)) (and b_d (not a_d)))))) :rule equiv_pos2)
(step t16 (cl (= (= (= (not (not (= a_d b_d))) (= a_d b_d)) true) (= (not (not (= a_d b_d))) (= a_d b_d)))) :rule equiv_simplify)
(step t17 (cl (not (= (= (not (not (= a_d b_d))) (= a_d b_d)) true)) (= (not (not (= a_d b_d))) (= a_d b_d))) :rule equiv1 :premises (t16))
(step t18 (cl (= (= (not (not (= a_d b_d))) (= a_d b_d)) (= (= a_d b_d) (not (not (= a_d b_d)))))) :rule all_simplify)
(step t19 (cl (= (= a_d b_d) (= a_d b_d))) :rule refl)
(step t20 (cl (= (not (not (= a_d b_d))) (= a_d b_d))) :rule all_simplify :args (not_simplify1 (= a_d b_d)))
(step t21 (cl (= (= (= a_d b_d) (not (not (= a_d b_d)))) (= (= a_d b_d) (= a_d b_d)))) :rule cong :premises (t19 t20))
(step t22 (cl (= (= (= a_d b_d) (= a_d b_d)) (and (=> (= a_d b_d) (= a_d b_d)) (=> (= a_d b_d) (= a_d b_d))))) :rule all_simplify :args (connective_def2 (= a_d b_d) (= a_d b_d)))
(step t23 (cl (= (and (=> (= a_d b_d) (= a_d b_d)) (=> (= a_d b_d) (= a_d b_d))) (=> (= a_d b_d) (= a_d b_d)))) :rule all_simplify :args (and_simplify3 (=> (= a_d b_d) (= a_d b_d)) (cvc5_nary_op) (cvc5_nary_op) (cvc5_nary_op)))
(step t24 (cl (= (=> (= a_d b_d) (= a_d b_d)) true)) :rule all_simplify :args (implies_simplify6 (= a_d b_d)))
(step t25 (cl (= (and (=> (= a_d b_d) (= a_d b_d)) (=> (= a_d b_d) (= a_d b_d))) true)) :rule trans :premises (t23 t24))
(step t26 (cl (= (= (= a_d b_d) (= a_d b_d)) true)) :rule trans :premises (t22 t25))
(step t27 (cl (= (= (= a_d b_d) (not (not (= a_d b_d)))) true)) :rule trans :premises (t21 t26))
(step t28 (cl (= (= (not (not (= a_d b_d))) (= a_d b_d)) true)) :rule trans :premises (t18 t27))
(step t29 (cl (= (not (not (= a_d b_d))) (= a_d b_d))) :rule resolution :premises (t17 t28))
(step t30 (cl (= (not (or (and a_d (not b_d)) (and b_d (not a_d)))) (not (or (and a_d (not b_d)) (and b_d (not a_d)))))) :rule refl)
(step t31 (cl (= (or (not (not (= a_d b_d))) (not (or (and a_d (not b_d)) (and b_d (not a_d))))) (or (= a_d b_d) (not (or (and a_d (not b_d)) (and b_d (not a_d))))))) :rule cong :premises (t29 t30))
(step t32 (cl (not (not (= a_d b_d))) (not (or (and a_d (not b_d)) (and b_d (not a_d))))) :rule not_equiv2 :premises (a0))
(step t33 (cl (or (not (not (= a_d b_d))) (not (or (and a_d (not b_d)) (and b_d (not a_d))))) (not (not (not (= a_d b_d))))) :rule or_neg)
(step t34 (cl (or (not (not (= a_d b_d))) (not (or (and a_d (not b_d)) (and b_d (not a_d))))) (not (not (or (and a_d (not b_d)) (and b_d (not a_d)))))) :rule or_neg)
(step t35 (cl (or (not (not (= a_d b_d))) (not (or (and a_d (not b_d)) (and b_d (not a_d))))) (or (not (not (= a_d b_d))) (not (or (and a_d (not b_d)) (and b_d (not a_d)))))) :rule resolution :premises (t32 t33 t34))
(step t36 (cl (or (not (not (= a_d b_d))) (not (or (and a_d (not b_d)) (and b_d (not a_d)))))) :rule contraction :premises (t35))
(step t37 (cl (or (= a_d b_d) (not (or (and a_d (not b_d)) (and b_d (not a_d)))))) :rule resolution :premises (t15 t31 t36))
(step t38 (cl (= a_d b_d) (not (or (and a_d (not b_d)) (and b_d (not a_d))))) :rule or :premises (t37))
(step t39 (cl (not (= (or (and a_d (not b_d)) (not a_d) (not (not b_d))) (or (and a_d (not b_d)) (not a_d) b_d))) (not (or (and a_d (not b_d)) (not a_d) (not (not b_d)))) (or (and a_d (not b_d)) (not a_d) b_d)) :rule equiv_pos2)
(step t40 (cl (= (and a_d (not b_d)) (and a_d (not b_d)))) :rule refl)
(step t41 (cl (= (not a_d) (not a_d))) :rule refl)
(step t42 (cl (= (= (= (not (not b_d)) b_d) true) (= (not (not b_d)) b_d))) :rule equiv_simplify)
(step t43 (cl (not (= (= (not (not b_d)) b_d) true)) (= (not (not b_d)) b_d)) :rule equiv1 :premises (t42))
(step t44 (cl (= (= (not (not b_d)) b_d) (= b_d (not (not b_d))))) :rule all_simplify)
(step t45 (cl (= b_d b_d)) :rule refl)
(step t46 (cl (= (not (not b_d)) b_d)) :rule all_simplify :args (not_simplify1 b_d))
(step t47 (cl (= (= b_d (not (not b_d))) (= b_d b_d))) :rule cong :premises (t45 t46))
(step t48 (cl (= (= b_d b_d) (and (=> b_d b_d) (=> b_d b_d)))) :rule all_simplify :args (connective_def2 b_d b_d))
(step t49 (cl (= (and (=> b_d b_d) (=> b_d b_d)) (=> b_d b_d))) :rule all_simplify :args (and_simplify3 (=> b_d b_d) (cvc5_nary_op) (cvc5_nary_op) (cvc5_nary_op)))
(step t50 (cl (= (=> b_d b_d) true)) :rule all_simplify :args (implies_simplify6 b_d))
(step t51 (cl (= (and (=> b_d b_d) (=> b_d b_d)) true)) :rule trans :premises (t49 t50))
(step t52 (cl (= (= b_d b_d) true)) :rule trans :premises (t48 t51))
(step t53 (cl (= (= b_d (not (not b_d))) true)) :rule trans :premises (t47 t52))
(step t54 (cl (= (= (not (not b_d)) b_d) true)) :rule trans :premises (t44 t53))
(step t55 (cl (= (not (not b_d)) b_d)) :rule resolution :premises (t43 t54))
(step t56 (cl (= (or (and a_d (not b_d)) (not a_d) (not (not b_d))) (or (and a_d (not b_d)) (not a_d) b_d))) :rule cong :premises (t40 t41 t55))
(step t57 (cl (and a_d (not b_d)) (not a_d) (not (not b_d))) :rule and_neg)
(step t58 (cl (or (and a_d (not b_d)) (not a_d) (not (not b_d))) (not (and a_d (not b_d)))) :rule or_neg)
(step t59 (cl (or (and a_d (not b_d)) (not a_d) (not (not b_d))) (not (not a_d))) :rule or_neg)
(step t60 (cl (or (and a_d (not b_d)) (not a_d) (not (not b_d))) (not (not (not b_d)))) :rule or_neg)
(step t61 (cl (or (and a_d (not b_d)) (not a_d) (not (not b_d))) (or (and a_d (not b_d)) (not a_d) (not (not b_d))) (or (and a_d (not b_d)) (not a_d) (not (not b_d)))) :rule resolution :premises (t57 t58 t59 t60))
(step t62 (cl (or (and a_d (not b_d)) (not a_d) (not (not b_d)))) :rule contraction :premises (t61))
(step t63 (cl (or (and a_d (not b_d)) (not a_d) b_d)) :rule resolution :premises (t39 t56 t62))
(step t64 (cl (and a_d (not b_d)) (not a_d) b_d) :rule or :premises (t63))
(step t65 (cl b_d (and a_d (not b_d)) (not a_d)) :rule reordering :premises (t64))
(step t66 (cl (not (= a_d b_d)) (not a_d) b_d) :rule equiv_pos2)
(step t67 (cl b_d (not (= a_d b_d)) (not a_d)) :rule reordering :premises (t66))
(step t68 (cl b_d (not a_d) b_d (not a_d)) :rule resolution :premises (t14 t38 t65 t67))
(step t69 (cl b_d (not a_d)) :rule contraction :premises (t68))
(step t70 (cl (not a_d) (not a_d)) :rule resolution :premises (t13 t69))
(step t71 (cl (not a_d)) :rule contraction :premises (t70))
(step t72 (cl (or (and a_d (not b_d)) (and b_d (not a_d))) (not (and b_d (not a_d)))) :rule or_neg)
(step t73 (cl (= a_d b_d) (not (or (and a_d (not b_d)) (and b_d (not a_d))))) :rule or :premises (t37))
(step t74 (cl (not (= (or (and b_d (not a_d)) (not b_d) (not (not a_d))) (or (and b_d (not a_d)) (not b_d) a_d))) (not (or (and b_d (not a_d)) (not b_d) (not (not a_d)))) (or (and b_d (not a_d)) (not b_d) a_d)) :rule equiv_pos2)
(step t75 (cl (= (and b_d (not a_d)) (and b_d (not a_d)))) :rule refl)
(step t76 (cl (= (not b_d) (not b_d))) :rule refl)
(step t77 (cl (= (= (= (not (not a_d)) a_d) true) (= (not (not a_d)) a_d))) :rule equiv_simplify)
(step t78 (cl (not (= (= (not (not a_d)) a_d) true)) (= (not (not a_d)) a_d)) :rule equiv1 :premises (t77))
(step t79 (cl (= (= (not (not a_d)) a_d) (= a_d (not (not a_d))))) :rule all_simplify)
(step t80 (cl (= a_d a_d)) :rule refl)
(step t81 (cl (= (not (not a_d)) a_d)) :rule all_simplify :args (not_simplify1 a_d))
(step t82 (cl (= (= a_d (not (not a_d))) (= a_d a_d))) :rule cong :premises (t80 t81))
(step t83 (cl (= (= a_d a_d) (and (=> a_d a_d) (=> a_d a_d)))) :rule all_simplify :args (connective_def2 a_d a_d))
(step t84 (cl (= (and (=> a_d a_d) (=> a_d a_d)) (=> a_d a_d))) :rule all_simplify :args (and_simplify3 (=> a_d a_d) (cvc5_nary_op) (cvc5_nary_op) (cvc5_nary_op)))
(step t85 (cl (= (=> a_d a_d) true)) :rule all_simplify :args (implies_simplify6 a_d))
(step t86 (cl (= (and (=> a_d a_d) (=> a_d a_d)) true)) :rule trans :premises (t84 t85))
(step t87 (cl (= (= a_d a_d) true)) :rule trans :premises (t83 t86))
(step t88 (cl (= (= a_d (not (not a_d))) true)) :rule trans :premises (t82 t87))
(step t89 (cl (= (= (not (not a_d)) a_d) true)) :rule trans :premises (t79 t88))
(step t90 (cl (= (not (not a_d)) a_d)) :rule resolution :premises (t78 t89))
(step t91 (cl (= (or (and b_d (not a_d)) (not b_d) (not (not a_d))) (or (and b_d (not a_d)) (not b_d) a_d))) :rule cong :premises (t75 t76 t90))
(step t92 (cl (and b_d (not a_d)) (not b_d) (not (not a_d))) :rule and_neg)
(step t93 (cl (or (and b_d (not a_d)) (not b_d) (not (not a_d))) (not (and b_d (not a_d)))) :rule or_neg)
(step t94 (cl (or (and b_d (not a_d)) (not b_d) (not (not a_d))) (not (not b_d))) :rule or_neg)
(step t95 (cl (or (and b_d (not a_d)) (not b_d) (not (not a_d))) (not (not (not a_d)))) :rule or_neg)
(step t96 (cl (or (and b_d (not a_d)) (not b_d) (not (not a_d))) (or (and b_d (not a_d)) (not b_d) (not (not a_d))) (or (and b_d (not a_d)) (not b_d) (not (not a_d)))) :rule resolution :premises (t92 t93 t94 t95))
(step t97 (cl (or (and b_d (not a_d)) (not b_d) (not (not a_d)))) :rule contraction :premises (t96))
(step t98 (cl (or (and b_d (not a_d)) (not b_d) a_d)) :rule resolution :premises (t74 t91 t97))
(step t99 (cl (and b_d (not a_d)) (not b_d) a_d) :rule or :premises (t98))
(step t100 (cl a_d (not b_d) (and b_d (not a_d))) :rule reordering :premises (t99))
(step t101 (cl (not (= a_d b_d)) a_d (not b_d)) :rule equiv_pos1)
(step t102 (cl a_d (not (= a_d b_d)) (not b_d)) :rule reordering :premises (t101))
(step t103 (cl (not b_d) (not b_d)) :rule resolution :premises (t72 t73 t100 t71 t102 t71))
(step t104 (cl (not b_d)) :rule contraction :premises (t103))
(step t105 (cl (= a_d b_d)) :rule resolution :premises (t5 t71 t104))
(step t106 (cl (or (and a_d (not b_d)) (and b_d (not a_d)))) :rule resolution :premises (t3 t105))
(step t107 (cl (not (and b_d (not a_d))) b_d) :rule and_pos)
(step t108 (cl b_d (not (and b_d (not a_d)))) :rule reordering :premises (t107))
(step t109 (cl (not (and b_d (not a_d)))) :rule resolution :premises (t108 t104))
(step t110 (cl (not (and a_d (not b_d))) a_d) :rule and_pos)
(step t111 (cl a_d (not (and a_d (not b_d)))) :rule reordering :premises (t110))
(step t112 (cl (not (and a_d (not b_d)))) :rule resolution :premises (t111 t71))
(step t113 (cl) :rule resolution :premises (t2 t106 t109 t112))
