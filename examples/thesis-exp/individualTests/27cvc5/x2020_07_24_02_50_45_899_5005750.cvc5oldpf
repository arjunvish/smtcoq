(assume a0 (not (= (ite p_d true q_d) (or p_d q_d))))
(step t1 (cl (not (= (not (= (ite p_d true q_d) (or p_d q_d))) false)) (not (not (= (ite p_d true q_d) (or p_d q_d)))) false) :rule equiv_pos2)
(step t2 (cl (= (ite p_d true q_d) (or p_d q_d))) :rule all_simplify :args (ite_simplify9 p_d q_d))
(step t3 (cl (= (or p_d q_d) (or p_d q_d))) :rule refl)
(step t4 (cl (= (= (ite p_d true q_d) (or p_d q_d)) (= (or p_d q_d) (or p_d q_d)))) :rule cong :premises (t2 t3))
(step t5 (cl (= (= (or p_d q_d) (or p_d q_d)) (and (=> (or p_d q_d) (or p_d q_d)) (=> (or p_d q_d) (or p_d q_d))))) :rule all_simplify :args (connective_def2 (or p_d q_d) (or p_d q_d)))
(step t6 (cl (= (and (=> (or p_d q_d) (or p_d q_d)) (=> (or p_d q_d) (or p_d q_d))) (=> (or p_d q_d) (or p_d q_d)))) :rule all_simplify :args (and_simplify3 (=> (or p_d q_d) (or p_d q_d)) (cvc5_nary_op) (cvc5_nary_op) (cvc5_nary_op)))
(step t7 (cl (= (=> (or p_d q_d) (or p_d q_d)) true)) :rule all_simplify :args (implies_simplify6 (or p_d q_d)))
(step t8 (cl (= (and (=> (or p_d q_d) (or p_d q_d)) (=> (or p_d q_d) (or p_d q_d))) true)) :rule trans :premises (t6 t7))
(step t9 (cl (= (= (or p_d q_d) (or p_d q_d)) true)) :rule trans :premises (t5 t8))
(step t10 (cl (= (= (ite p_d true q_d) (or p_d q_d)) true)) :rule trans :premises (t4 t9))
(step t11 (cl (= (not (= (ite p_d true q_d) (or p_d q_d))) (not true))) :rule cong :premises (t10))
(step t12 (cl (= (not true) false)) :rule not_simplify)
(step t13 (cl (= (not (= (ite p_d true q_d) (or p_d q_d))) false)) :rule trans :premises (t11 t12))
(step t14 (cl false) :rule resolution :premises (t1 t13 a0))
(step t15 (cl (not false)) :rule false)
(step t16 (cl) :rule resolution :premises (t14 t15))
