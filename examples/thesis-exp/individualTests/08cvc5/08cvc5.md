No exceptions are raised, but checker fails.

Proof File: x2020_07_29_04_44_56_253_5688612.cvc5oldpf
SMT File: x2020_07_29_04_44_56_253_5688612.smt_in
Path: /home/arjun/Desktop/smtcoq/arjunvish-smtcoq-veritAst/smtcoq/examples/thesis-exp/sledgehammer-benchmarks-cvc5-old/Benchmarks/Ordered_Resolution_Prover_veriT

Problem: 
For this step:
```
(step t2 (cl (= (not (not (true_cls_d (interp_d s_d n_d) (plus_d (sum_mset_d (mset_d cs_d)) d_d)))) (true_cls_d (interp_d s_d n_d) (plus_d (sum_mset_d (mset_d cs_d)) d_d)))) :rule all_simplify :args (not_simplify1 (true_cls_d (interp_d s_d n_d) (plus_d (sum_mset_d (mset_d cs_d)) d_d))))
```
The DSL does the right thing, but our handling of the `not_simplify` rule might be wrong. We replace a derivation of
`~~x = x` by `x = x` since SMTCoq reasons modulo double negation elimination but perhaps this assumption is too strong.
SMTCoq reasons modulo double negation only when the double negation is at the head of one of the terms in a clause derived
by a step. This double negation is inside a term (equality is the head).

Fix: What's the right way to implement this transformation? Basically we need to derive `x` from `~~x` and vice-versa.