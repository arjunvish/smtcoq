No exceptions are raised, but checker fails.

Proof File: x2020_07_28_21_17_40_281_7539822.cvc5oldpf
SMT File: x2020_07_28_21_17_40_281_7539822.smt_in
Path: /home/arjun/Desktop/smtcoq/arjunvish-smtcoq-veritAst/smtcoq/examples/thesis-exp/sledgehammer-benchmarks-cvc5-old/Benchmarks/Ordered_Resolution_Prover_veriT

Problem: 
For this step:
```
(step t2 (cl (= (not (not (and (generalizes_d subst_atm_d d_d c_d) (not (generalizes_d subst_atm_d c_d d_d))))) (and (generalizes_d subst_atm_d d_d c_d) (not (generalizes_d subst_atm_d c_d d_d))))) :rule all_simplify :args (not_simplify1 (and (generalizes_d subst_atm_d d_d c_d) (not (generalizes_d subst_atm_d c_d d_d)))))
```
The DSL does the right thing, but our handling of the `not_simplify` rule might be wrong. We replace a derivation of
`~~x = x` by `x = x` since SMTCoq reasons modulo double negation elimination but perhaps this assumption is too strong.
SMTCoq reasons modulo double negation only when the double negation is at the head of one of the terms in a clause derived
by a step. This double negation is inside a term (equality is the head).

Fix: What's the right way to implement this transformation? Basically we need to derive `x` from `~~x` and vice-versa.