(assume a0 (not (< 0 n_d)))
(assume a1 (< 1 n_d))
(step t0 (cl (not (= (< (+ n_d (* -1 n_d)) (+ 1 (* -1 2))) false)) (not (< (+ n_d (* -1 n_d)) (+ 1 (* -1 2)))) false) :rule equiv_pos2)
(step t1 (cl (= (< (+ n_d (* -1 n_d)) (+ 1 (* -1 2))) (not (>= (+ n_d (* -1 n_d)) (+ 1 (* -1 2)))))) :rule all_simplify)
(step t2 (cl (= (+ n_d (* -1 n_d)) 0)) :rule all_simplify)
(step t3 (cl (= 1 1)) :rule refl)
(step t4 (cl (= (* -1 2) -2)) :rule all_simplify)
(step t5 (cl (= (+ 1 (* -1 2)) (+ 1 -2))) :rule cong :premises (t3 t4))
(step t6 (cl (= (+ 1 -2) -1)) :rule all_simplify)
(step t7 (cl (= (+ 1 (* -1 2)) -1)) :rule trans :premises (t5 t6))
(step t8 (cl (= (>= (+ n_d (* -1 n_d)) (+ 1 (* -1 2))) (>= 0 -1))) :rule cong :premises (t2 t7))
(step t9 (cl (= (>= 0 -1) true)) :rule all_simplify)
(step t10 (cl (= (>= (+ n_d (* -1 n_d)) (+ 1 (* -1 2))) true)) :rule trans :premises (t8 t9))
(step t11 (cl (= (not (>= (+ n_d (* -1 n_d)) (+ 1 (* -1 2)))) (not true))) :rule cong :premises (t10))
(step t12 (cl (= (not true) false)) :rule all_simplify)
(step t13 (cl (= (not (>= (+ n_d (* -1 n_d)) (+ 1 (* -1 2)))) false)) :rule trans :premises (t11 t12))
(step t14 (cl (= (< (+ n_d (* -1 n_d)) (+ 1 (* -1 2))) false)) :rule trans :premises (t1 t13))
(step t15 (cl (not (< n_d 1)) (not (<= (* -1 n_d) (* -1 2))) (< (+ n_d (* -1 n_d)) (+ 1 (* -1 2)))) :rule la_generic :args (1 1 1))
(step t16 (cl (not (= (not (>= n_d 1)) (< n_d 1))) (not (not (>= n_d 1))) (< n_d 1)) :rule equiv_pos2)
(step t17 (cl (= (< n_d 1) (not (>= n_d 1)))) :rule all_simplify)
(step t18 (cl (= (not (>= n_d 1)) (< n_d 1))) :rule symm :premises (t17))
(step t19 (cl (not (= (not (< 0 n_d)) (not (>= n_d 1)))) (not (not (< 0 n_d))) (not (>= n_d 1))) :rule equiv_pos2)
(step t20 (cl (= (< 0 n_d) (not (>= 0 n_d)))) :rule all_simplify)
(step t21 (cl (= (>= 0 n_d) (not (>= n_d 1)))) :rule all_simplify)
(step t22 (cl (= (not (>= 0 n_d)) (not (not (>= n_d 1))))) :rule cong :premises (t21))
(step t23 (cl (= (not (not (>= n_d 1))) (>= n_d 1))) :rule all_simplify)
(step t24 (cl (= (not (>= 0 n_d)) (>= n_d 1))) :rule trans :premises (t22 t23))
(step t25 (cl (= (< 0 n_d) (>= n_d 1))) :rule trans :premises (t20 t24))
(step t26 (cl (= (not (< 0 n_d)) (not (>= n_d 1)))) :rule cong :premises (t25))
(step t27 (cl (not (>= n_d 1))) :rule resolution :premises (t19 t26 a0))
(step t28 (cl (< n_d 1)) :rule resolution :premises (t16 t18 t27))
(step t29 (cl (=> (and (< -1 0) (>= n_d 2)) (<= (* -1 n_d) (* -1 2)))) :rule la_mult_neg)
(step t30 (cl (not (and (< -1 0) (>= n_d 2))) (<= (* -1 n_d) (* -1 2))) :rule implies :premises (t29))
(step t31 (cl (and (< -1 0) (>= n_d 2)) (not (< -1 0)) (not (>= n_d 2))) :rule and_neg)
(step t32 (cl (= (= (< -1 0) true) (< -1 0))) :rule equiv_simplify)
(step t33 (cl (not (= (< -1 0) true)) (< -1 0)) :rule equiv1 :premises (t32))
(step t34 (cl (= (< -1 0) true)) :rule rare_rewrite :args ("evaluate"))
(step t35 (cl (< -1 0)) :rule resolution :premises (t33 t34))
(step t36 (cl (not (= (< 1 n_d) (>= n_d 2))) (not (< 1 n_d)) (>= n_d 2)) :rule equiv_pos2)
(step t37 (cl (= (< 1 n_d) (not (>= 1 n_d)))) :rule all_simplify)
(step t38 (cl (= (>= 1 n_d) (not (>= n_d 2)))) :rule all_simplify)
(step t39 (cl (= (not (>= 1 n_d)) (not (not (>= n_d 2))))) :rule cong :premises (t38))
(step t40 (cl (= (not (not (>= n_d 2))) (>= n_d 2))) :rule all_simplify)
(step t41 (cl (= (not (>= 1 n_d)) (>= n_d 2))) :rule trans :premises (t39 t40))
(step t42 (cl (= (< 1 n_d) (>= n_d 2))) :rule trans :premises (t37 t41))
(step t43 (cl (>= n_d 2)) :rule resolution :premises (t36 t42 a1))
(step t44 (cl (and (< -1 0) (>= n_d 2))) :rule resolution :premises (t31 t35 t43))
(step t45 (cl (<= (* -1 n_d) (* -1 2))) :rule resolution :premises (t30 t44))
(step t46 (cl (< (+ n_d (* -1 n_d)) (+ 1 (* -1 2)))) :rule resolution :premises (t15 t28 t45))
(step t47 (cl false) :rule resolution :premises (t0 t14 t46))
(step t48 (cl (not false)) :rule false)
(step t49 (cl) :rule resolution :premises (t47 t48))
