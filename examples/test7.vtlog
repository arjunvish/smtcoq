(assume h1 (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))
(step t2 (cl (= (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) (and (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))) :rule bool_simplify)
(step t3 (cl (not (= (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) (and (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))) (not (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) (and (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) :rule equiv_pos2)
(step t4 (cl (not (not (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))) (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) :rule not_not)
(step t5 (cl (not (= (not (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) (and (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))) (=> (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))) (and (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) :rule th_resolution :premises (t4 t3))
(step t6 (cl (and (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) :rule th_resolution :premises (h1 t2 t5))
(step t7 (cl (= (+ (* 2 op_2) 1) (+ 1 (* 2 op_2)))) :rule sum_simplify)
(step t8 (cl (= (+ (* 2 op_3) 1) (+ 1 (* 2 op_3)))) :rule sum_simplify)
(step t9 (cl (= (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))))) :rule cong :premises (t7 t8))
(step t10 (cl (= (= (+ (* 2 op_2) 1) (* 2 op_3)) (= (* 2 op_3) (+ 1 (* 2 op_2))))) :rule cong :premises (t7))
(step t11 (cl (= (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2)))))) :rule cong :premises (t9 t10))
(step t12 (cl (= (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (+ 1 (* 2 op_3))))) :rule cong :premises (t8))
(step t13 (cl (= (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3))))) :rule cong :premises (t12))
(step t14 (cl (= (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (ite op_0 (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2)))) (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3)))))) :rule cong :premises (t11 t13))
(step t15 (cl (= (and (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) (and (ite op_0 (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2)))) (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))) :rule cong :premises (t14))
(step t16 (cl (not (= (and (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) (and (ite op_0 (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2)))) (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))))) (not (and (ite op_0 (ite op_1 (= (+ (* 2 op_2) 1) (+ (* 2 op_3) 1)) (= (+ (* 2 op_2) 1) (* 2 op_3))) (ite op_1 (= (* 2 op_2) (+ (* 2 op_3) 1)) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) (and (ite op_0 (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2)))) (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) :rule equiv_pos2)
(step t17 (cl (and (ite op_0 (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2)))) (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3)))) (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3))))) :rule th_resolution :premises (t6 t15 t16))
(step t18 (cl (ite op_0 (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2)))) (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3))))) :rule and :premises (t17))
(step t19 (cl (not (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3)))) op_1 (= (* 2 op_2) (* 2 op_3))) :rule ite_pos1)
(step t20 (cl (not (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3)))) (not op_1) (= (* 2 op_2) (+ 1 (* 2 op_3)))) :rule ite_pos2)
(step t21 (cl (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3))) op_1 (not (= (* 2 op_2) (* 2 op_3)))) :rule ite_neg1)
(step t22 (cl op_0 (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3)))) :rule ite1 :premises (t18))
(step t23 (cl (not (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2))))) op_1 (= (* 2 op_3) (+ 1 (* 2 op_2)))) :rule ite_pos1)
(step t24 (cl (not (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2))))) (not op_1) (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3)))) :rule ite_pos2)
(step t25 (cl (not op_0) (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2))))) :rule ite2 :premises (t18))
(step t26 (cl (not (and (=> op_0 op_1) (=> op_1 op_0) (= op_2 op_3)))) :rule and :premises (t17))
(step t27 (cl (=> op_0 op_1) op_0) :rule implies_neg1)
(step t28 (cl (=> op_0 op_1) (not op_1)) :rule implies_neg2)
(step t29 (cl (=> op_1 op_0) op_1) :rule implies_neg1)
(step t30 (cl (=> op_1 op_0) (not op_0)) :rule implies_neg2)
(step t31 (cl (not (=> op_0 op_1)) (not (=> op_1 op_0)) (not (= op_2 op_3))) :rule not_and :premises (t26))
(step t32 (cl (<= (* 2 op_2) (* 2 op_3)) (<= (* 2 op_3) (* 2 op_2))) :rule la_generic :args (1 1))
(step t33 (cl (<= (* 2 op_3) (* 2 op_2)) (not (= (* 2 op_2) (+ 1 (* 2 op_3))))) :rule la_generic :args (1 1))
(step t34 (cl (not (= (* 2 op_2) (* 2 op_3))) (not (= (* 2 op_2) (* 2 op_3))) (not (<= (* 2 op_2) (* 2 op_3))) (<= (* 2 op_3) (* 2 op_2))) :rule eq_congruent_pred)
(step t35 (cl (not (= (* 2 op_2) (* 2 op_3))) (not (<= (* 2 op_2) (* 2 op_3))) (<= (* 2 op_3) (* 2 op_2))) :rule contraction :premises (t34))
(step t36 (cl (<= (* 2 op_3) (* 2 op_2)) (not (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3))))) :rule resolution :premises (t35 t19 t20 t33 t32))
(step t37 (cl (or (= op_2 op_3) (not (<= op_2 op_3)) (not (<= op_3 op_2)))) :rule la_disequality)
(step t38 (cl (= op_2 op_3) (not (<= op_2 op_3)) (not (<= op_3 op_2))) :rule or :premises (t37))
(step t39 (cl (not (<= (* 2 op_3) (* 2 op_2))) (<= op_3 op_2)) :rule la_generic :args (1 2))
(step t40 (cl (not (<= (* 2 op_2) (* 2 op_3))) (<= op_2 op_3)) :rule la_generic :args (1 2))
(step t41 (cl (not (= (* 2 op_2) (* 2 op_3))) (not (= (* 2 op_3) (+ 1 (* 2 op_2)))) (not (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3)))) (= (* 2 op_2) (+ 1 (* 2 op_3)))) :rule eq_transitive)
(step t42 (cl (not (= 1 1)) (not (= (* 2 op_2) (* 2 op_3))) (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3)))) :rule eq_congruent)
(step t43 (cl (= 1 1)) :rule eq_reflexive)
(step t44 (cl (not (= (* 2 op_2) (* 2 op_3))) (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3)))) :rule th_resolution :premises (t42 t43))
(step t45 (cl (not (= (* 2 op_2) (* 2 op_3))) (not (= (* 2 op_3) (+ 1 (* 2 op_2)))) (= (* 2 op_2) (+ 1 (* 2 op_3))) (not (= (* 2 op_2) (* 2 op_3)))) :rule th_resolution :premises (t41 t44))
(step t46 (cl (not (= (* 2 op_2) (* 2 op_3))) (not (= (* 2 op_3) (+ 1 (* 2 op_2)))) (= (* 2 op_2) (+ 1 (* 2 op_3)))) :rule contraction :premises (t45))
(step t47 (cl (= (* 2 op_2) (+ 1 (* 2 op_3))) op_1 (not (=> op_1 op_0)) (not (<= op_2 op_3)) (not (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3))))) :rule resolution :premises (t46 t23 t25 t27 t31 t38 t39 t19 t36))
(step t48 (cl (not (= 2 2)) (not (= op_2 op_3)) (= (* 2 op_2) (* 2 op_3))) :rule eq_congruent)
(step t49 (cl (= 2 2)) :rule eq_reflexive)
(step t50 (cl (not (= op_2 op_3)) (= (* 2 op_2) (* 2 op_3))) :rule th_resolution :premises (t48 t49))
(step t51 (cl (<= op_3 op_2) (not (= (* 2 op_3) (+ 1 (* 2 op_2))))) :rule la_generic :args (2 (- 1)))
(step t52 (cl (not (<= op_2 op_3)) op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (not (=> op_1 op_0))) :rule resolution :premises (t51 t38 t50 t23 t25 t22 t21 t47))
(step t53 (cl (<= op_2 op_3) (not (= (* 2 op_3) (+ 1 (* 2 op_2))))) :rule la_generic :args (2 1))
(step t54 (cl (not (= (* 2 op_2) (* 2 op_3))) (not (= (* 2 op_2) (* 2 op_3))) (not (<= (* 2 op_3) (* 2 op_2))) (<= (* 2 op_2) (* 2 op_3))) :rule eq_congruent_pred)
(step t55 (cl (not (= (* 2 op_2) (* 2 op_3))) (not (<= (* 2 op_3) (* 2 op_2))) (<= (* 2 op_2) (* 2 op_3))) :rule contraction :premises (t54))
(step t56 (cl op_1 (<= op_2 op_3)) :rule resolution :premises (t55 t19 t22 t25 t23 t53 t32 t40))
(step t57 (cl (not (<= op_2 op_3)) (not (<= (+ 1 (* 2 op_3)) (* 2 op_2)))) :rule la_generic :args (2 1))
(step t58 (cl (not (= (* 2 op_3) (+ 1 (* 2 op_3)))) (not (= (* 2 op_2) (* 2 op_2))) (<= (+ 1 (* 2 op_3)) (* 2 op_2)) (not (<= (* 2 op_3) (* 2 op_2)))) :rule eq_congruent_pred)
(step t59 (cl (not (= (* 2 op_2) (* 2 op_3))) (not (= (* 2 op_2) (+ 1 (* 2 op_3)))) (= (* 2 op_3) (+ 1 (* 2 op_3)))) :rule eq_transitive)
(step t60 (cl (not (= (* 2 op_2) (+ 1 (* 2 op_3)))) (= (* 2 op_3) (+ 1 (* 2 op_3))) (not (= op_2 op_3))) :rule th_resolution :premises (t59 t50))
(step t61 (cl (not (= (* 2 op_2) (* 2 op_2))) (<= (+ 1 (* 2 op_3)) (* 2 op_2)) (not (<= (* 2 op_3) (* 2 op_2))) (not (= (* 2 op_2) (+ 1 (* 2 op_3)))) (not (= op_2 op_3))) :rule th_resolution :premises (t58 t60))
(step t62 (cl (= (* 2 op_2) (* 2 op_2))) :rule eq_reflexive)
(step t63 (cl (<= (+ 1 (* 2 op_3)) (* 2 op_2)) (not (<= (* 2 op_3) (* 2 op_2))) (not (= (* 2 op_2) (+ 1 (* 2 op_3)))) (not (= op_2 op_3))) :rule th_resolution :premises (t61 t62))
(step t64 (cl op_1) :rule resolution :premises (t57 t63 t38 t39 t33 t52 t56 t29))
(step t65 (cl (=> op_0 op_1)) :rule resolution :premises (t28 t64))
(step t66 (cl (not (= (* 2 op_2) (+ 1 (* 2 op_3)))) (not (= (* 2 op_2) (* 2 op_3)))) :rule resolution :premises (t63 t38 t57 t40 t55 t39 t33))
(step t67 (cl (= op_2 op_3) (not (= (* 2 op_2) (* 2 op_3))) (not (<= (* 2 op_3) (* 2 op_2)))) :rule resolution :premises (t40 t38 t55 t39))
(step t68 (cl (not (= (* 2 op_2) (* 2 op_3)))) :rule resolution :premises (t35 t32 t67 t31 t30 t22 t20 t66 t65 t64))
(step t69 (cl (not (= op_2 op_3))) :rule resolution :premises (t50 t68))
(step t70 (cl (<= op_3 op_2) (not (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))))) :rule la_generic :args (2 1))
(step t71 (cl (<= (* 2 op_3) (* 2 op_2))) :rule resolution :premises (t70 t24 t25 t38 t22 t40 t36 t32 t64 t69))
(step t72 (cl (<= op_3 op_2)) :rule resolution :premises (t39 t71))
(step t73 (cl (not (<= op_2 op_3))) :rule resolution :premises (t38 t72 t69))
(step t74 (cl (<= op_2 op_3) (not (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))))) :rule la_generic :args (2 (- 1)))
(step t75 (cl (not (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))))) :rule resolution :premises (t74 t73))
(step t76 (cl (not (ite op_1 (= (+ 1 (* 2 op_2)) (+ 1 (* 2 op_3))) (= (* 2 op_3) (+ 1 (* 2 op_2)))))) :rule resolution :premises (t24 t75 t64))
(step t77 (cl (not op_0)) :rule resolution :premises (t25 t76))
(step t78 (cl (ite op_1 (= (* 2 op_2) (+ 1 (* 2 op_3))) (= (* 2 op_2) (* 2 op_3)))) :rule resolution :premises (t22 t77))
(step t79 (cl (= (* 2 op_2) (+ 1 (* 2 op_3)))) :rule resolution :premises (t20 t78 t64))
(step t80 (cl (<= op_2 op_3) (not (= (* 2 op_2) (+ 1 (* 2 op_3))))) :rule la_generic :args (2 (- 1)))
(step t81 (cl) :rule resolution :premises (t80 t79 t73))
